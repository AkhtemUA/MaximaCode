@c /linearalgebra.texi/1.11/Fri Jan  5 17:01:04 2007//
@menu
* Introdu@value{cedilha}@~ao a linearalgebra::
* Defini@value{cedilha}@~oes para linearalgebra::
@end menu

@node Introdu@value{cedilha}@~ao a linearalgebra, Defini@value{cedilha}@~oes para linearalgebra, linearalgebra, linearalgebra
@section Introdu@value{cedilha}@~ao a linearalgebra

@code{linearalgebra} @'e uma colec@,{c}@~ao de fun@value{cedilha}@~oes para @'algebra linear.

Exemplo:

@c ===beg===
@c load (linearalgebra)$
@c M : matrix ([1, 2], [1, 2]);
@c nullspace (M);
@c columnspace (M);
@c ptriangularize (M - z*ident(2), z);
@c M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
@c MM : ptriangularize (M, z);
@c algebraic : true;
@c tellrat (MM [3, 3]);
@c MM : ratsimp (MM);
@c nullspace (MM);
@c M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]);
@c columnspace (M);
@c apply ('orthogonal_complement, args (nullspace (transpose (M))));
@c ===end===
@example
(%i1) load (linearalgebra);
Warning - you are redefining the Maxima function require_list
Warning - you are redefining the Maxima function matrix_size
Warning - you are redefining the Maxima function rank
(%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
(%i2) M : matrix ([1, 2], [1, 2]);
                            [ 1  2 ]
(%o2)                       [      ]
                            [ 1  2 ]
(%i3) nullspace (M);
                               [  1  ]
                               [     ]
(%o3)                     span([   1 ])
                               [ - - ]
                               [   2 ]
(%i4) columnspace (M);
                                [ 1 ]
(%o4)                      span([   ])
                                [ 1 ]
(%i5) ptriangularize (M - z*ident(2), z);
                         [ 1   2 - z   ]
(%o5)                    [             ]
                         [           2 ]
                         [ 0  3 z - z  ]
(%i6) M : matrix ([1, 2, 3], [4, 5, 6], [7, 8, 9]) - z*ident(3);
                     [ 1 - z    2      3   ]
                     [                     ]
(%o6)                [   4    5 - z    6   ]
                     [                     ]
                     [   7      8    9 - z ]
(%i7) MM : ptriangularize (M, z);
              [ 4  5 - z            6            ]
              [                                  ]
              [                2                 ]
              [     66        z    102 z   132   ]
              [ 0   --      - -- + ----- + ---   ]
(%o7)         [     49        7     49     49    ]
              [                                  ]
              [               3        2         ]
              [           49 z    245 z    147 z ]
              [ 0    0    ----- - ------ - ----- ]
              [            264      88      44   ]
(%i8) algebraic : true;
(%o8)                         true
(%i9) tellrat (MM [3, 3]);
                         3       2
(%o9)                  [z  - 15 z  - 18 z]
(%i10) MM : ratsimp (MM);
               [ 4  5 - z           6           ]
               [                                ]
               [                2               ]
(%o10)         [     66      7 z  - 102 z - 132 ]
               [ 0   --    - ------------------ ]
               [     49              49         ]
               [                                ]
               [ 0    0             0           ]
(%i11) nullspace (MM);
                        [        1         ]
                        [                  ]
                        [   2              ]
                        [  z  - 14 z - 16  ]
                        [  --------------  ]
(%o11)             span([        8         ])
                        [                  ]
                        [    2             ]
                        [   z  - 18 z - 12 ]
                        [ - -------------- ]
                        [         12       ]
(%i12) M : matrix ([1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]);
                       [ 1   2   3   4  ]
                       [                ]
                       [ 5   6   7   8  ]
(%o12)                 [                ]
                       [ 9   10  11  12 ]
                       [                ]
                       [ 13  14  15  16 ]
(%i13) columnspace (M);
                           [ 1  ]  [ 2  ]
                           [    ]  [    ]
                           [ 5  ]  [ 6  ]
(%o13)                span([    ], [    ])
                           [ 9  ]  [ 10 ]
                           [    ]  [    ]
                           [ 13 ]  [ 14 ]
(%i14) apply ('orthogonal_complement, args (nullspace (transpose (M))));
                           [ 0 ]  [  1  ]
                           [   ]  [     ]
                           [ 1 ]  [  0  ]
(%o14)                span([   ], [     ])
                           [ 2 ]  [ - 1 ]
                           [   ]  [     ]
                           [ 3 ]  [ - 2 ]
@end example

@node Defini@value{cedilha}@~oes para linearalgebra,  , Introdu@value{cedilha}@~ao a linearalgebra, linearalgebra
@section Defini@value{cedilha}@~oes para linearalgebra

@deffn {Fun@value{cedilha}@~ao} addmatrices (@mvar{f}, @mvar{M_1}, ..., @mvar{M_n})

@c REWORD -- THE RESULT IS NOT GENERALLY THE SUM OF M_1, ..., M_N
Usando a fun@value{cedilha}@~ao @mvar{f} como a fun@value{cedilha}@~ao de adi@value{cedilha}@~ao, retorne a adi@value{cedilha}@~ao das
matrizes @mvar{M_1}, ..., @mvar{M_n}. A fun@value{cedilha}@~ao @mvar{f} deve aceitar qualquer n@'umero de
argumentos (uma fun@value{cedilha}@~ao en@'aria do Maxima).

Exemplos:

@c ===beg===
@c m1 : matrix([1,2],[3,4])$
@c m2 : matrix([7,8],[9,10])$
@c addmatrices('max,m1,m2);
@c addmatrices('max,m1,m2,5*m1);
@c ===end===
@example
(%i1) m1 : matrix([1,2],[3,4])$
(%i2) m2 : matrix([7,8],[9,10])$
(%i3) addmatrices('max,m1,m2);
(%o3) matrix([7,8],[9,10])
(%i4) addmatrices('max,m1,m2,5*m1);
(%o4) matrix([7,10],[15,20])
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} blockmatrixp (@mvar{M})

Retorna @code{true} se e somente se @mvar{M} for uma matriz e toda entrada de
@mvar{M} tamb@'em for uma matriz.

@end deffn

@deffn {Fun@value{cedilha}@~ao} columnop (@mvar{M}, @mvar{i}, @mvar{j}, @mvar{theta})

Se @mvar{M} for uma matriz, retorna a matriz que resulta de fazer a  
opera@value{cedilha}@~ao de coluna @code{C_i <- C_i - @mvar{theta} * C_j}. Se @mvar{M} n@~ao tiver uma linha
@mvar{i} ou @mvar{j}, emite uma mensagem de erro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} columnswap (@mvar{M}, @mvar{i}, @mvar{j})

Se @mvar{M} for uma matriz, troca as colunas @mvar{i} e @mvar{j}.  Se @mvar{M} n@~ao tiver uma coluna
@mvar{i} ou @mvar{j}, emite uma mensagem de erro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} columnspace (@mvar{M})

Se @mvar{M} for uma matriz, retorna @code{span (v_1, ..., v_n)}, onde o conjunto
@code{@{v_1, ..., v_n@}} @'e uma base para o espa@value{cedilha}o coluna de @mvar{M}.  A diferen@value{cedilha}a entre o maior elemento e o menor elemento do 
conjunto vazio @'e @code{@{0@}}. Dessa forma, quando o espa@value{cedilha}o coluna tiver somente 
um membro, retorna @code{span ()}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} copy (@mvar{e})

Retorna uma c@'opia da express@~ao @mvar{e} do Maxima. Embora @mvar{e} possa ser qualquer
express@~ao do Maxima, Afun@value{cedilha}@~ao @code{copy} @'e mais @'util quando @mvar{e} for ou
uma lista ou uma matriz; considere:
@c ===beg===
load (linearalgebra);
m : [1,[2,3]]$
mm : m$
mm[2][1] : x$
m;
mm;
@c ===end===
@example 
(%i1) load("linearalgebra")$
(%i2) m : [1,[2,3]]$
(%i3) mm : m$
(%i4) mm[2][1] : x$
(%i5) m;
(%o5) [1,[x,3]]
(%i6) mm;
(%o6) [1,[x,3]]
@end example
Vamos tentar a mesma experi@^encia, mas dessa vez tomemos @mvar{mm} como sendo uma c@'opia de @mvar{m}
@c ===beg===
m : [1,[2,3]]$
mm : copy(m)$
mm[2][1] : x$
m;
mm;
@c ===end===
@example
(%i7) m : [1,[2,3]]$
(%i8) mm : copy(m)$
(%i9) mm[2][1] : x$
(%i10) m;
(%o10) [1,[2,3]]
(%i11) mm;
(%o11) [1,[x,3]]
@end example
Dessa vez, a atribui@value{cedilha}@~ao a @mvar{mm} n@~ao muda o valor de @mvar{m}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} cholesky (@mvar{M})
@deffnx {Fun@value{cedilha}@~ao} cholesky (@mvar{M}, @mvar{corpo})

Retorna factoriza@value{cedilha}@~ao de Cholesky da matriz hermitiana (or autoadjunta) 
@mvar{M}. O valor padr@~ao para o segundo argumento @'e @code{generalring}. Para uma descri@value{cedilha}@~ao dos
poss@'{@dotless{i}}veis valores para @mvar{corpo}, veja @code{lu_factor}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ctranspose (@mvar{M})

Retorna a matriz transposta conjugada complexa da matriz @mvar{M}. A fun@value{cedilha}@~ao
@code{ctranspose} usa @code{matrix_element_transpose} para transpor cada elemento da matriz.

@end deffn

@deffn {Fun@value{cedilha}@~ao} diag_matrix (@mvar{d_1}, @mvar{d_2},...,@mvar{d_n})

Retorna uma matriz diagonal matriz com entradas de diagonal @mvar{d_1}, @mvar{d_2},...,@mvar{d_n}.
Quando as entradas de diagonal forem matrizes, as entradas zero da matriz retornada
ser@~ao todas matrizes de tamanho apropriado; por exemplo:
@c ===beg===
@c load(linearalgebra)$
@c diag_matrix(diag_matrix(1,2),diag_matrix(3,4));
@c diag_matrix(p,q);
@c ===end===
@example
(%i1) load(linearalgebra)$

(%i2) diag_matrix(diag_matrix(1,2),diag_matrix(3,4));

                            [ [ 1  0 ]  [ 0  0 ] ]
                            [ [      ]  [      ] ]
                            [ [ 0  2 ]  [ 0  0 ] ]
(%o2)                       [                    ]
                            [ [ 0  0 ]  [ 3  0 ] ]
                            [ [      ]  [      ] ]
                            [ [ 0  0 ]  [ 0  4 ] ]
(%i3) diag_matrix(p,q);

                                   [ p  0 ]
(%o3)                              [      ]
                                   [ 0  q ]
@end example
@end deffn

@deffn {Fun@value{cedilha}@~ao} dotproduct (@mvar{u}, @mvar{v})

Retorna o produto do ponto (produto escalar) dos vectores @mvar{u} e @mvar{v}.  Isso @'e o mesmo
que @code{conjugate (transpose (@mvar{u})) . @mvar{v}}.  Os argumentos @mvar{u} e @mvar{v} devem ser
vectores coluna.

@end deffn

@deffn {Fun@value{cedilha}@~ao} eigens_by_jacobi (@mvar{A})
@deffnx {Fun@value{cedilha}@~ao} eigens_by_jacobi (@mvar{A}, @mvar{tipo_corpo})

Calculam os autovalores e autovectores de @mvar{A} pelo m@'etodo de rota@value{cedilha}@~oes de Jacobi.
@mvar{A} deve ser uma matriz sim@'etrica (mas essa matriz sim@'etrica precisa n@~ao ser nem definida positiva e nem semidefinida positiva).
@mvar{tipo_corpo} indica o corpo computacional, pode ser ou @code{floatfield} ou @code{bigfloatfield}.
Se @mvar{tipo_corpo} n@~ao for especificado, o padr@~ao @'e @code{floatfield}.

Os elementos de @mvar{A} devem ser n@'umeros ou express@~oes que avaliam para n@'umeros
via @code{float} ou @code{bfloat} (dependendo do valor de @mvar{tipo_corpo}).

Exemplos:
@c ===beg===
@c load (linearalgebra);
@c S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);
@c L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
@c M : S . L . transpose (S);
@c eigens_by_jacobi (M);
@c float ([[sqrt(3), sqrt(5)], S]);
@c eigens_by_jacobi (M, bigfloatfield);
@c ===end===

@example
(%i1) load (linearalgebra);
(%o1) /home/robert/tmp/maxima-head/maxima/share/linearalgebra/li\
nearalgebra.mac
(%i2) S : matrix ([1/sqrt(2), 1/sqrt(2)], [- 1/sqrt(2), 1/sqrt(2)]);
                     [     1         1    ]
                     [  -------   ------- ]
                     [  sqrt(2)   sqrt(2) ]
(%o2)                [                    ]
                     [      1        1    ]
                     [ - -------  ------- ]
                     [   sqrt(2)  sqrt(2) ]
(%i3) L : matrix ([sqrt(3), 0], [0, sqrt(5)]);
                      [ sqrt(3)     0    ]
(%o3)                 [                  ]
                      [    0     sqrt(5) ]
(%i4) M : S . L . transpose (S);
            [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
            [ ------- + -------  ------- - ------- ]
            [    2         2        2         2    ]
(%o4)       [                                      ]
            [ sqrt(5)   sqrt(3)  sqrt(5)   sqrt(3) ]
            [ ------- - -------  ------- + ------- ]
            [    2         2        2         2    ]
(%i5) eigens_by_jacobi (M);
The largest percent change was 0.1454972243679
The largest percent change was 0.0
number of sweeps: 2
number of rotations: 1
(%o5) [[1.732050807568877, 2.23606797749979], 
                        [  0.70710678118655   0.70710678118655 ]
                        [                                      ]]
                        [ - 0.70710678118655  0.70710678118655 ]
(%i6) float ([[sqrt(3), sqrt(5)], S]);
(%o6) [[1.732050807568877, 2.23606797749979], 
                        [  0.70710678118655   0.70710678118655 ]
                        [                                      ]]
                        [ - 0.70710678118655  0.70710678118655 ]
(%i7) eigens_by_jacobi (M, bigfloatfield);
The largest percent change was 1.454972243679028b-1
The largest percent change was 0.0b0
number of sweeps: 2
number of rotations: 1
(%o7) [[1.732050807568877b0, 2.23606797749979b0], 
                [  7.071067811865475b-1   7.071067811865475b-1 ]
                [                                              ]]
                [ - 7.071067811865475b-1  7.071067811865475b-1 ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} get_lu_factors (@mvar{x}) 

Quando @code{@mvar{x} = lu_factor (@mvar{A})}, ent@~ao @code{get_lu_factors} retorna uma lista da 
forma @code{[P, L, U]}, onde @mvar{P} @'e uma matriz de permuta@value{cedilha}@~ao, @mvar{L} @'e triangular baixa com
a diagonal preenchida com a unidade, e @mvar{U} @'e triangular alta, e @code{@mvar{A} = @mvar{P} @mvar{L} @mvar{U}}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} hankel (@mvar{col})
@deffnx {Fun@value{cedilha}@~ao} hankel (@mvar{col}, @mvar{lin})

Retorna uma matriz de Hankel @mvar{H}. A primeira coluna de @mvar{H} @'e @mvar{col};
excepto para a primeira entrada, a @'ultima linha de @mvar{H} @'e @mvar{lin}. O
valor padr@~ao para @mvar{lin} @'e o vector nulo com o mesmo comprimento que @mvar{col}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} hessian (@mvar{f},@mvar{vars})

Retorna a matriz hessiana de @mvar{f} com rela@value{cedilha}@~ao @`as vari@'aveis na lista
@mvar{vars}.  As entradas @mvar{i},@mvar{j} da matriz hessiana s@~ao
@mvar{diff(f vars[i],1,vars[j],1)}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} hilbert_matrix (@mvar{n})

Retorna the @mvar{n} by @mvar{n} matriz de Hilbert. Quando @mvar{n} n@~ao for um inteiro
positivo, emite uma mensagem de erro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} identfor (@mvar{M})
@deffnx {Fun@value{cedilha}@~ao} identfor (@mvar{M}, @mvar{corpo})

Retorna uma matriz identidade que tem o mesmo tamanho que a matriz
@mvar{M}.  As entradas de diagonal da matriz identidade s@~ao a 
identidade multiplicativa do corpo @mvar{corpo}; o padr@~ao para
@mvar{corpo} @'e @mvar{generalring}.

O primeiro argumento @mvar{M} pode ser uma  matriz quadrada ou um 
n@~ao matriz. Quando @mvar{M} for uma matriz, cada entrada de @mvar{M} pode ser uma
matriz quadrada -- dessa forma @mvar{M} pode ser uma matriz de bloco do Maxima. A
matriz pode ser de bloco para qualquer (finita) quantidade de n@'{@dotless{i}}veis.

Veja tamb@'em @code{zerofor}

@end deffn

@deffn {Fun@value{cedilha}@~ao} invert_by_lu (@mvar{M}, @mvar{(rng generalring)})

Inverte a matriz @mvar{M} atrav@'es de factoriza@value{cedilha}@~ao linear alta (LU).  A factoriza@value{cedilha}@~ao LU
@'e conclu@'{@dotless{i}}da usando o anel @mvar{rng}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} kronecker_product (@mvar{A}, @mvar{B})

Retorna o produto de Kronecker das matrizes @mvar{A} e @mvar{B}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} listp (@mvar{e}, @mvar{p})
@deffnx {Fun@value{cedilha}@~ao} listp (@mvar{e})

Recebendo um argumento opcional @mvar{p}, retorna @code{true} se @mvar{e} for 
uma lista do Maxima e @mvar{p} avalia para @code{true} para elemento da lista.
Quando @code{listp} n@~ao recebe o argumento opcional, retorna @code{true} se @mvar{e} for 
uma lista do Maxima.  em todos os outros casos, retorna @code{false}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} locate_matrix_entry (@mvar{M}, @mvar{r_1}, @mvar{c_1}, @mvar{r_2}, @mvar{c_2}, @mvar{f}, @mvar{rel})

O primeiro argumento deve ser uma matriz; os argumentos que v@~ao de
@mvar{r_1} at@'e @mvar{c_2} determinam um sub-matriz de @mvar{M} que consiste de
linhas que v@~ao de @mvar{r_1} at@'e @mvar{r_2} e colunas que v@~ao de @mvar{c_1} at@'e @mvar{c_2}. 

Encontra uma entrada na sub-matriz @mvar{M} que satisfaz alguma propriedade. 
Existem tr@^es casos:

(1) @code{@mvar{rel} = 'bool} e @mvar{f} um predicado: 

Examina a sub-matriz da esquerda para a direita e de cima para baixo,
e retorna o @'{@dotless{i}}ndice da primeira entrada que satisfizer o 
predicado @mvar{f}. Se nenhuma entrada da matriz satisfizer o predicado @mvar{f}, retorna @code{false}.

(2) @code{@mvar{rel} = 'max} e @mvar{f} avaliar para um n@'umero real:

Examina a sub-matriz procurando por uma entrada que maximize @mvar{f}.
Retorna retorna o @'{@dotless{i}}ndice da entrada maximizada.

(3) @code{@mvar{rel} = 'min} e @mvar{f} avaliar para um n@'umero real:

Examina a sub-matriz procurando por uma entrada que minimize @mvar{f}. 
Retorna o @'{@dotless{i}}ndice de uma entrada minimizada.

@end deffn

@deffn {Fun@value{cedilha}@~ao} lu_backsub (@mvar{M}, @mvar{b})

Quando @code{@mvar{M} = lu_factor (@mvar{A}, @mvar{corpo})},
ent@~ao @code{lu_backsub (@mvar{M}, @mvar{b})} resolve o sistema
linear @code{@mvar{A} @mvar{x} = @mvar{b}}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} lu_factor (@mvar{M}, @mvar{corpo})

Retorna uma lista da forma @code{[@mvar{LU}, @mvar{perm}, @mvar{corpo}]}, 
ou da forma @code{[@mvar{LU}, @mvar{perm}, @mvar{cmp}, @mvar{baixo-cnd} @mvar{alto-cnd}]}, onde

  (1) A matriz @mvar{LU} cont@'ea factoriza@value{cedilha}@~ao de @mvar{M} na forma enpacotada. Forma
      empacotada significa tr@^es coisas: Primeiro, as linhas de @mvar{LU} s@~ao permutadas confirme a 
      lista @mvar{perm}.  Se, por exemplo, @mvar{perm} for a lista list @code{[3,2,1]}, a primeira linha actual 
      da factoriza@value{cedilha}@~ao @mvar{LU} ser@'a a terceira linha da matriz @mvar{LU}. Segundo,
      o factor triangular baixo de m @'e a parte triangular baixa de @mvar{LU} com as
      entradas de diagonal todas substitu@'{@dotless{i}}das pela unidade. Terceiro, o factor triangular alto de 
      @mvar{M} @'e a parte triangular alta de @mvar{LU}.  

  (2) Quando o corpo for ou @code{floatfield} ou @code{complexfield},
      os n@'umeros @mvar{baixo-cnd} e @mvar{alto-cnd} ser@~ao associados baixo e alto para o 
      n@'umero condicional de norma infinita de @mvar{M}.  Para todos os corpos (fields), o n@'umero condicional de norma infinita 
      n@~ao pode ser estimado; para tais corpos, @code{lu_factor} retorna uma lista com dois itens.
      Ambos o baixo e o alto associado  podem diferir de seus verdadeiros valores de 
      factores arbitr@'ariamente grandes. (Veja tamb@'em @code{mat_cond}.)
   
  O argumento @mvar{M} deve ser a matriz quadrada.

  O argumento opcional @mvar{cmp} deve ser um s@'{@dotless{i}}mbolo que determine um anel ou corpo. Os corpos e an@'eis 
  predefinidos s@~ao:

    (a) @code{generalring} -- o anel de express@~oes do Maxima,
    (b) @code{floatfield} --  o corpo dos n@'umeros em ponto flutuante do tipo de precis@~ao dupla,
    (c) @code{complexfield} --  o corpo dos n@'umeros complexos em ponto flutuante do 
        tipo de precis@~ao dupla,
    (d) @code{crering}  -- o anel das express@~oes racionais can@'onicas (CRE) do Maxima,
    (e) @code{rationalfield} -- o corpo dos n@'umeros racionais,
    (f) @code{runningerror} -- rastro de todos os erros de arredondamento de n@'umeros em ponto flutuante,
     (g) @code{noncommutingring} -- o anel de express@~oes do Maxima onde multiplica@value{cedilha}@~ao for o
        operador ponto n@~ao comutativo.       

Quando o corpo for @code{floatfield}, @code{complexfield}, ou
@code{runningerror}, o algoritmo usa pivotagem parcial; para todos
os outros corpos, linhas s@~ao comutadas somente quando necess@'ario para evitar um piv@^o
nulo.

A adi@value{cedilha}@~ao aritm@'etica em ponto flutuante n@~ao @'e associativa, ent@~ao o significado
de 'corpo' difere da defini@value{cedilha}@~ao matem@'atica.

Um membro do corpo @code{runningerror} @'e uma lista do M@'axima de dois membros
da forma @code{[x,n]},onde @mvar{x} @'e um n@'umero em onto flutuante e
@code{n} @'e um inteiro. A diferen@value{cedilha}a relativa entre o valor de
'verdadeiro' de @code{x} e @code{x} @'e aproximadamente associado pelo @'epsilon da
m@'aquina vezes @code{n}. O erro de execu@value{cedilha}@~ao associado arrasta alguns termos
da ordem do quadrado do @'epsilon da m@'aquina.

N@~ao existe interface de utilizador definida um novo anel. Um utilizador que estiver
familiazrizado com o Lisp Comum est@'a apto para definir um novo corpo.  Para fazer
isso, um utilizador deve definir fun@value{cedilha}@~oes para as opera@value{cedilha}@~oes aritm@'eticas e
fun@value{cedilha}@~oes para convers@~ao para a representa@value{cedilha}@~ao de corpo do M@'axima e
vice-versa. Adicionalmente, para corpos ordenados (onde a pivotagem parcial ser@'a
usada), um udu@'ario deve definir fun@value{cedilha}@~oes para m@'odulo e para
comparar membros do corpo.  Ap@'os isso tudo que resta @'e definir uma
estrutura de Lisp Comum @code{mring}.  O ficheiro @code{mring} tem muitos
exemplos.
 
Para calcular a factoriza@value{cedilha}@~ao, a primeira tarefa @'e converter cada entrada de
matriz para um elemento do corpo indicado. Quando a cnvers@~ao n@~ao for
poss@'{@dotless{i}}vel, a factoriza@value{cedilha}@~ao encerra com uma mensagem de erro. Elementos do
corpo n@~ao precisam ser express@~oes do Maxima.  Elementos do
@code{complexfield}, por exemplo, s@~ao n@'umeros complexos do Lisp Comum. Dessa forma
ap@'os calcular a factoriza@value{cedilha}@~ao, como entradas da matriz devem ser
convertidas para express@~oes do Maxima.

Veja tamb@'em  @code{get_lu_factors}.

Exemplos:
@c ===beg===
@c load (linearalgebra);
@c w[i,j] := random (1.0) + %i * random (1.0);
@c showtime : true$
@c M : genmatrix (w, 100, 100)$
@c lu_factor (M, complexfield)$
@c lu_factor (M, generalring)$
@c showtime : false$
@c M : matrix ([1 - z, 3], [3, 8 - z]);
@c lu_factor (M, generalring);
@c get_lu_factors (%);
@c %[1] . %[2] . %[3];
@c ===end===
@example
(%i1) load (linearalgebra);
Warning - you are redefining the Maxima function require_list
Warning - you are redefining the Maxima function matrix_size
Warning - you are redefining the Maxima function rank
(%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
(%i2) w[i,j] := random (1.0) + %i * random (1.0);
(%o2)          w     := random(1.) + %i random(1.)
                i, j
(%i3) showtime : true$
Evaluation took 0.00 seconds (0.00 elapsed)
(%i4) M : genmatrix (w, 100, 100)$
Evaluation took 7.40 seconds (8.23 elapsed)
(%i5) lu_factor (M, complexfield)$
Evaluation took 28.71 seconds (35.00 elapsed)
(%i6) lu_factor (M, generalring)$
Evaluation took 109.24 seconds (152.10 elapsed)
(%i7) showtime : false$

(%i8) M : matrix ([1 - z, 3], [3, 8 - z]); 
                        [ 1 - z    3   ]
(%o8)                   [              ]
                        [   3    8 - z ]
(%i9) lu_factor (M, generalring);
               [ 1 - z         3        ]
               [                        ]
(%o9)         [[   3            9       ], [1, 2]]
               [ -----  - z - ----- + 8 ]
               [ 1 - z        1 - z     ]
(%i10) get_lu_factors (%);
                  [   1    0 ]  [ 1 - z         3        ]
        [ 1  0 ]  [          ]  [                        ]
(%o10) [[      ], [   3      ], [                9       ]]
        [ 0  1 ]  [ -----  1 ]  [   0    - z - ----- + 8 ]
                  [ 1 - z    ]  [              1 - z     ]
(%i11) %[1] . %[2] . %[3];
                        [ 1 - z    3   ]
(%o11)                  [              ]
                        [   3    8 - z ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} mat_cond (@mvar{M}, 1)
@deffnx {Fun@value{cedilha}@~ao} mat_cond (@mvar{M}, inf)

Retorna o n@'umero condiciona da norma de ordem @mvar{p} da matriz
@mvar{m}. Os valores permitidos para @mvar{p} s@~ao 1 e @mvar{inf}.  Essa
fun@value{cedilha}@~ao utiliza a factoriza@value{cedilha}@~ao linear alta para inverter a matriz @mvar{m}. Dessa forma
o tempode execu@value{cedilha}@~ao para @code{mat_cond} @'e proporcional ao cubo do
tamanho da matriz; @code{lu_factor} determina as associa@value{cedilha}@~aoes baixa e alta
para o n@'umero de condi@value{cedilha}@~ao de norma infinita em tempo proporcional ao
quadrado do tamanho da matriz.

@end deffn

@deffn {Fun@value{cedilha}@~ao} mat_norm (@mvar{M}, 1)
@deffnx {Fun@value{cedilha}@~ao} mat_norm (@mvar{M}, inf)
@deffnx {Fun@value{cedilha}@~ao} mat_norm (@mvar{M}, frobenius)

Retorna a matriz de norma @mvar{p} da matriz @mvar{M}.  Os valores permitidos para @mvar{p} s@~ao
1, @code{inf}, e @code{frobenius} (a norma da matriz de Frobenius). A matriz @mvar{M} pode ser
uma matriz n@~ao de bloco.

@end deffn

@deffn {Fun@value{cedilha}@~ao} matrixp (@mvar{e}, @mvar{p})
@deffnx {Fun@value{cedilha}@~ao} matrixp (@mvar{e})

Fornecendo um argumento opcional @mvar{p}, @code{matrixp} retorna @code{true} se @mvar{e} for
uma matriz e @mvar{p} avaliar para @code{true} para todo elemento da matriz.
Quando a @code{matrixp} n@~ao for fornecido umargumento opcional, retorna @code{true} 
se @code{e} for uma matriz.  em todos os outros casos, retorna @code{false}.

Veja tamb@'em @code{blockmatrixp}

@end deffn

@deffn {Fun@value{cedilha}@~ao} matrix_size (@mvar{M})

Retorna uma lista com dois elementos que fornecem o n@'umero de linhas e colunas, respectivamente
da matriz @mvar{M}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} mat_fullunblocker (@mvar{M})

Se @mvar{M} for uma matriz de bloco, expande todos os blocos da matriz em todos os n@'{@dotless{i}}veis. Se @mvar{M} for uma matriz,
retorna @mvar{M}; de outra forma, emite uma mensagem de erro. 

@c precisa de exemplo aqui

@end deffn

@deffn {Fun@value{cedilha}@~ao} mat_trace (@mvar{M})

Retorna o tra@value{cedilha}o da matriz @mvar{M}. Se @mvar{M} n@~ao for uma matriz, retorna uma
forma substantiva. Quando @mvar{M} for uma matriz de bloco, @code{mat_trace(M)} retorna
o mesmo valor retornado por @code{mat_trace(mat_unblocker(m))}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} mat_unblocker (@mvar{M})

Se @mvar{M} for uma matriz de bloco, @code{mat_unbloker} desfaz o bloco de @mvar{M} um n@'{@dotless{i}}vel. Se @mvar{M} for uma matriz, 
@code{mat_unblocker (M)} retorna @mvar{M}; de outra forma, emite uma mensagem de erro.

Dessa forma se cada entrada de @mvar{M} for matriz, @code{mat_unblocker (M)} retorna uma 
matriz "desblocada", mas se cada entrada de @mvar{M} for uma matriz de bloco, @code{mat_unblocker (M)} 
retorna uma matriz de bloco com um n@'{@dotless{i}}vel de bloco a menos.

Se usar matrizes de bloco, muito provavelmente ir@'a querer escolher @code{matrix_element_mult} para 
@code{"."} e @code{matrix_element_transpose} para @code{'transpose}. Veja tamb@'em @code{mat_fullunblocker}.

Exemplo:

@c ===beg===
@c load (linearalgebra);
@c A : matrix ([1, 2], [3, 4]);
@c B : matrix ([7, 8], [9, 10]);
@c matrix ([A, B]);
@c mat_unblocker (%);
@c ===end===
@example
(%i1) load (linearalgebra);
Warning - you are redefining the Maxima function require_list
Warning - you are redefining the Maxima function matrix_size
Warning - you are redefining the Maxima function rank
(%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
(%i2) A : matrix ([1, 2], [3, 4]);
                            [ 1  2 ]
(%o2)                       [      ]
                            [ 3  4 ]
(%i3) B : matrix ([7, 8], [9, 10]);
                            [ 7  8  ]
(%o3)                       [       ]
                            [ 9  10 ]
(%i4) matrix ([A, B]);
                     [ [ 1  2 ]  [ 7  8  ] ]
(%o4)                [ [      ]  [       ] ]
                     [ [ 3  4 ]  [ 9  10 ] ]
(%i5) mat_unblocker (%);
                         [ 1  2  7  8  ]
(%o5)                    [             ]
                         [ 3  4  9  10 ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} nonnegintegerp (@mvar{n})

Retorna @code{true} se e somente se @code{@mvar{n} >= 0} e @mvar{n} for um inteiro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} nullspace (@mvar{M})

Se @mvar{M} for uma matriz, retorna @code{span (v_1, ..., v_n)}, onde o conjunto @code{@{v_1, ..., v_n@}}
@'e uma base para o espa@value{cedilha}o nulo de @mvar{M}.  A diferen@value{cedilha}a entre o maior elemento e o menor elemento do conjunto vazio @'e  @code{@{0@}}.  
Dessa forma, quando o espa@value{cedilha}o nulo tiver somente um membro, retorna @code{span ()}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} nullity (@mvar{M})

Se @mvar{M} for uma matriz, retorna a dimens@~ao do espa@value{cedilha}o nulo de @mvar{M}.

@end deffn

@deffn {Fun@value{cedilha}@~ao} orthogonal_complement (@mvar{v_1}, ..., @mvar{v_n})

Retorna @code{span (u_1, ..., u_m)}, onde o conjunto @code{@{u_1, ..., u_m@}} @'e uma 
base para o complemento ortogonal do conjunto @code{(v_1, ..., v_n)}.

Cada vector no intervalo de @mvar{v_1} at@'e @mvar{v_n} deve ser um vector coluna.

@end deffn

@deffn {Fun@value{cedilha}@~ao} polynomialp (@mvar{p}, @mvar{L}, @mvar{coeffp}, @mvar{exponp})
@deffnx {Fun@value{cedilha}@~ao} polynomialp (@mvar{p}, @mvar{L}, @mvar{coeffp})
@deffnx {Fun@value{cedilha}@~ao} polynomialp (@mvar{p}, @mvar{L})

Retorna @code{true} se @mvar{p} for um polin@'omio nas vari@'aveis da lista @mvar{L},
O predicado @mvar{coeffp} deve avaliar para @code{true} para cada
coeficiente, e o predicado @mvar{exponp} deve avaliar para @code{true} para todos os 
expoentes das vari@'aveis na lista @mvar{L}. Se quiser usar um valor
personalizado para @mvar{exponp}, dever@'a fornecer @mvar{coeffp} com um valor mesmo se quiser
o valor padr@~ao para @mvar{coeffp}.

@c WORK THE FOLLOWING INTO THE PRECEDING
@code{polynomialp (@mvar{p}, @mvar{L}, @mvar{coeffp})} @'e equivalente a
@code{polynomialp (@mvar{p}, @mvar{L}, @mvar{coeffp}, 'nonnegintegerp)}.

@code{polynomialp (@mvar{p}, @mvar{L})} @'e equivalente a
@code{polynomialp (@mvar{p}, L@mvar{,} 'constantp, 'nonnegintegerp)}.

O polin@'omio n@~ao precisa ser expandido:

@c ===beg===
@c load (linearalgebra);
@c polynomialp ((x + 1)*(x + 2), [x]);
@c polynomialp ((x + 1)*(x + 2)^a, [x]);
@c ===end===
@example
(%i1) load (linearalgebra);
Warning - you are redefining the Maxima function require_list
Warning - you are redefining the Maxima function matrix_size
Warning - you are redefining the Maxima function rank
(%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
(%i2) polynomialp ((x + 1)*(x + 2), [x]);
(%o2)                         true
(%i3) polynomialp ((x + 1)*(x + 2)^a, [x]);
(%o3)                         false
@end example

Um exemplo usando um valor personalizado para @code{coeffp} e para @code{exponp}:

@c ===beg===
@c load (linearalgebra);
@c polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
@c polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp, numberp);
@c ===end===
@example
(%i1) load (linearalgebra);
Warning - you are redefining the Maxima function require_list
Warning - you are redefining the Maxima function matrix_size
Warning - you are redefining the Maxima function rank
(%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
(%i2) polynomialp ((x + 1)*(x + 2)^(3/2), [x], numberp, numberp);
(%o2)                         true
(%i3) polynomialp ((x^(1/2) + 1)*(x + 2)^(3/2), [x], numberp, numberp);
(%o3)                         true
@end example

Polin@'omios com duas vari@'aveis:

@c ===beg===
@c load (linearalgebra);
@c polynomialp (x^2 + 5*x*y + y^2, [x]);
@c polynomialp (x^2 + 5*x*y + y^2, [x, y]);
@c ===end===
@example
(%i1) load (linearalgebra);
Warning - you are redefining the Maxima function require_list
Warning - you are redefining the Maxima function matrix_size
Warning - you are redefining the Maxima function rank
(%o1) /usr/local/share/maxima/5.9.2/share/linearalgebra/linearalgebra.mac
(%i2) polynomialp (x^2 + 5*x*y + y^2, [x]);
(%o2)                         false
(%i3) polynomialp (x^2 + 5*x*y + y^2, [x, y]);
(%o3)                         true
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} polytocompanion (@mvar{p}, @mvar{x})

Se @mvar{p} for um polin@'omio em @mvar{x}, retorna a atriz companheira de @mvar{p}. Para
um polin@'omio m@^onico @mvar{p} de grau @mvar{n},
temos @code{@mvar{p} = (-1)^@mvar{n} charpoly (polytocompanion (@mvar{p}, @mvar{x}))}.

Quando @mvar{p} n@~ao for um polin@'omio em @mvar{x}, emite uma mensagem de erro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} ptriangularize (@mvar{M}, @mvar{v})

Se @mvar{M} for uma matriz onde cada entrada dessa matriz for um polin@'omio em @mvar{v}, retorna 
a matriz @mvar{M2} tal que

(1) @mvar{M2} @'e triangular alta,

(2) @code{@mvar{M2} = @mvar{E_n} ... @mvar{E_1} @mvar{M}},
onde os elemetnos de @mvar{E_1} a @mvar{E_n} s@~ao matrizes elementares 
cujas entrada s@~ao polin@'omios em @mvar{v},

(3) @code{|det (@mvar{M})| = |det (@mvar{M2})|},

Nota: Essa fun@value{cedilha}@~ao n@~ao verifica se toda entrada @'e um polin@'omio em @mvar{v}.  

@end deffn

@deffn {Fun@value{cedilha}@~ao} rowop (@mvar{M}, @mvar{i}, @mvar{j}, @mvar{theta})

Se @mvar{M} for uma matriz, retorna a matriz que resulta de se fazer a  
opera@value{cedilha}@~ao de linha @code{R_i <- R_i - theta * R_j}. Se @mvar{M} n@~ao tiver uma linha
@mvar{i} ou @mvar{j}, emite uma mensagem de erro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} rank (@mvar{M})

Retorna o ranque daquela matriz @mvar{M}. O rank @'e a dimens@~ao do
espa@value{cedilha}o coluna. Exemplo:
@c ===beg===
@c load (linearalgebra)$
@c rank(matrix([1,2],[2,4]));
@c rank(matrix([1,b],[c,d]));
@c ===end===
@example
(%i1) load (linearalgebra)$
WARNING: DEFUN/DEFMACRO: redefining function $COPY in
         /share/maxima/5.11.0/share/linearalgebra/linalg-utilities.lisp,
         was defined in
         /maxima-5.11.0/src/binary-clisp/comm2.fas
(%i2) rank(matrix([1,2],[2,4]));
(%o2)                                  1
(%i3) rank(matrix([1,b],[c,d]));
Proviso:  @{d - b c # 0@}
(%o3)                                  2
@end example

@end deffn


@deffn {Fun@value{cedilha}@~ao} rowswap (@mvar{M}, @mvar{i}, @mvar{j})

Se @mvar{M} for uma matriz, permuta as linha @mvar{i} e @mvar{j}. Se @mvar{M} n@~ao tiver uma linha
@mvar{i} ou @mvar{j}, emite uma mensagem de erro.

@end deffn

@deffn {Fun@value{cedilha}@~ao} toeplitz (@mvar{col})
@deffnx {Fun@value{cedilha}@~ao} toeplitz (@mvar{col}, @mvar{lin})

Retorna uma matriz de Toeplitz @mvar{T}. a primeira coluna de @mvar{T} @'e @mvar{col};
excepto para a primeira entrada, a primeira linha de @mvar{T} @'e @mvar{lin}. O
padr@~ao para @mvar{lin} @'e o conjugado complexo de @mvar{col}. Exemplo:
@c ===beg===
@c load(linearalgebra)$
@c toeplitz([1,2,3],[x,y,z]);
@c toeplitz([1,1+%i]);
@c ==end===
@example
(%i1) load(linearalgebra)$

(%i2)  toeplitz([1,2,3],[x,y,z]);

                                  [ 1  y  z ]
                                  [         ]
(%o2)                             [ 2  1  y ]
                                  [         ]
                                  [ 3  2  1 ]
(%i3)  toeplitz([1,1+%i]);

                              [   1     1 - %I ]
(%o3)                         [                ]
                              [ %I + 1    1    ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~ao} vandermonde_matrix ([@mvar{x_1}, ..., @mvar{x_n}])

Retorna uma matriz @mvar{n} por @mvar{n} cuja @mvar{i}-@'esima linha @'e 
@code{[1, @mvar{x_i}, @mvar{x_i}^2, ... @mvar{x_i}^(@mvar{n}-1)]}. 

@end deffn

@deffn {Fun@value{cedilha}@~ao} zerofor (@mvar{M})
@deffnx {Fun@value{cedilha}@~ao}  zerofor (@mvar{M}, @mvar{fld})

Retorna uma matriz zero que tem o mesmo tamanho da matriz
@mvar{M}.  Toda entrada da matriz zero @'e a
identidade aditiva do anel @mvar{fld}; o valor padr@~ao para
@mvar{fld} @'e @mvar{generalring}.

O primeiro argumento @mvar{M} pode ser uma matriz quadrada ou uma
n@~ao matriz. Quando @mvar{M} for uma matriz, cada entrada de @mvar{M} pode ser uma
matriz quadrada -- dessa forma @mvar{M} pode ser uma matriz de bloco do Maxima. A
matriz pode ser de bloco para qualquer n@'{@dotless{i}}vel (finito).

Veja tamb@'em @code{identfor}

@end deffn

@deffn {Fun@value{cedilha}@~ao} zeromatrixp (@mvar{M})

Se @mvar{M} n@~ao for uma matriz de bloco, retorna @code{true} se @code{is (equal (@mvar{e}, 0))} 
for verdadeiro para cada elemento @mvar{e} da matriz @mvar{M}.  Se @mvar{M} for uma matriz de bloco, retorna
@code{true} se @code{zeromatrixp} avaliar para @code{true} para cada elemento de @mvar{e}.

@end deffn
