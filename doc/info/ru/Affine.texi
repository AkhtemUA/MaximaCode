@c Language=Russian
@c Encoding=CP1251
@c File=Affine.texi 
@c OriginalRevision=1.16
@c TranslatedBy: (c) 2005-12 Vadim V. Zhytnikov <vvzhyt@gmail.ru>

@menu
* Введение в пакет affine::      
* Функции и переменные пакета affine::      
@end menu

@node Введение в пакет affine, Функции и переменные пакета affine, Пакет affine, Пакет affine
@section Введение в пакет affine

Пакет @code{affine} предназначен для работы с группами многочленов.

@opencatbox
@category{Многочлены} @category{Базисы Гребнера} @category{Пакеты библиотеки share} @category{Пакет affine}
@closecatbox


@node Функции и переменные пакета affine,  , Введение в пакет affine, Пакет affine
@section Функции и переменные пакета affine

@deffn {Функция} fast_linsolve ([@mvar{expr_1}, ..., @mvar{expr_m}], [@mvar{x_1}, ..., @mvar{x_n}])
Решает систему линейных уравнений @mvar{expr_1}, ..., @mvar{expr_m}
относительно переменных  @mvar{x_1}, ..., @mvar{x_n}.
Каждый аргумент @mvar{expr_i} может быть уравнением или произвольным выражением.
В последнем случае выражение трактуется как уравнение вида @code{@mvar{expr_i} = 0}.

Возвращаемое значение является списком вида
@code{[@mvar{x_1} = @mvar{a_1}, ..., @mvar{x_n} = @mvar{a_n}]},
где @mvar{a_1}, ..., @mvar{a_n} не зависят от переменных @mvar{x_1}, ..., @mvar{x_n}.

@code{fast_linsolve} более быстрый чем @code{linsolve} для разреженных систем.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@deffn {Функция} grobner_basis ([@mvar{expr_1}, ..., @mvar{expr_m}])
Возвращает базис Гребнера для уравнений  @mvar{expr_1}, ..., @mvar{expr_m}.
После этого функция @code{polysimp} может быть использована для
упрощения других выражений по функций относительно данной
системы уравнений.

@example
grobner_basis ([3*x^2+1, y*x])$

polysimp (y^2*x + x^3*9 + 2) ==> -3*x + 2
@end example

@code{polysimp(f)} возвращает 0 тогда и только тогда, когда @mvar{f} принадлежит
идеалу уравнений @mvar{expr_1}, ..., @mvar{expr_m}.  Иными словами, тогда и только тогда,
когда @mvar{f} является полиномиальной комбинацией элементов
@mvar{expr_1}, ..., @mvar{expr_m}.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION IN A SERIOUS WAY
@deffn {Функция} set_up_dot_simplifications (@mvar{eqns}, @mvar{check_through_degree})
@deffnx {Функция} set_up_dot_simplifications (@mvar{eqns})
Уравнения @mvar{eqns} являются полиномиальными уравнениями относительно
некоммутативных переменных.
Значение @code{current_variables} есть список переменных,
используемых для вычисления степеней.  Уравнения должны быть
однородными по степеням, для того, чтобы процедура сходилась.

Если перекрывающиеся упрощения в @code{dot_simplifications} проверены
до степени выше степени @mvar{f}, тогда верно следующее:
@code{dotsimp(@mvar{f})} дает 0 тогда и только тогда, когда @mvar{f}
принадлежит идеалу уравнений, т.е., тогда и только тогда, когда
@mvar{f} является полиномиальной комбинацией уравнений.

Здесь степень определяется с помощью @code{nc_degree} и зависит от
весов отдельных переменных.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@deffn {Функция} declare_weights (@mvar{x_1}, @mvar{w_1}, ..., @mvar{x_n}, @mvar{w_n})
Присваивает веса @mvar{w_1}, ..., @mvar{w_n} переменным @mvar{x_1}, ..., @mvar{x_n}.
Эти веса используются при вычислении @code{nc_degree}.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@deffn {Функция} nc_degree (@mvar{p})
Возвращает степень некоммутативного полинома @mvar{p}.
См. также @code{declare_weights}.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@c NEEDS CLARIFICATION -- TO WHICH EQUATIONS DOES THIS DESCRIPTION REFER ??
@deffn {Функция} dotsimp (@mvar{f})
Возвращает 0 тогда и только тогда, когда @mvar{f} принадлежит идеалу уравнений, т.е.,
тогда и только тогда, когда @mvar{f} является полиномиальной
комбинацией элементов уравнений.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@deffn {Функция} fast_central_elements ([@mvar{x_1}, ..., @mvar{x_n}], @mvar{n})
Если @code{set_up_dot_simplifications} было уже выполнено, тогда
данная функция возвращает центральные полиномы степени @mvar{n}
по переменным @mvar{x_1}, ..., @mvar{x_n}.

Например:
@example
set_up_dot_simplifications ([y.x + x.y], 3);
fast_central_elements ([x, y], 2);
[y.y, x.x];
@end example

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@c THIS IS NOT AT ALL CLEAR
@deffn {Функция} check_overlaps (@mvar{n}, @mvar{add_to_simps})
Проверяет перекрытия до степени @mvar{n},
чтобы убедиться, что имеется достаточно правил упрощения для каждой
степени чтобы @code{dotsimp} работало правильно.  Этот процесс может
быть ускорен если заранее известна размерность пространства мономов.
Если размерность конечная и глобальная, тогда следует использовать
@code{hilbert}.
Если мономиальная размерность неизвестна, то не
следут задавать @code{rank_function}.
Необязательный третий аргумент @code{reset}, @code{false} означает --
не следует спрашивать о переопределении объектов.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@deffn {Функция} mono ([@mvar{x_1}, ..., @mvar{x_n}], @mvar{n})
Возвращает список независимых мономов по отношению к текущим
упрощениям степени @mvar{n} по переменным @mvar{x_1}, ..., @mvar{x_n}.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@deffn {Функция} monomial_dimensions (@mvar{n})
Вычисляет ряд Гильберта до степени @mvar{n} для текущей алгебры.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@deffn {Функция} extract_linear_equations ([@mvar{p_1}, ..., @mvar{p_n}], [@mvar{m_1}, ..., @mvar{m_n}])
Возвращает список коэффициентов некоммутативных полиномов @mvar{p_1}, ..., @mvar{p_n}
некоммутативных мономов @mvar{m_1}, ..., @mvar{m_n}.
Коэффициенты должны быть скалярными.  Для получения списка мономов
используется @code{list_nc_monomials}.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@deffn {Функция} list_nc_monomials ([@mvar{p_1}, ..., @mvar{p_n}])
@deffnx {Функция} list_nc_monomials (@mvar{p})
Возвращает список некоммутативных мономов полинома @mvar{p}
или списка полиномов @mvar{p_1}, ..., @mvar{p_n}.

Команда @code{load(affine)} загружает эту функцию.

@opencatbox
@category{Пакет affine}
@closecatbox
@end deffn

@c THIS FUNCTION DOESN'T SEEM TO BE APPROPRIATE IN USER-LEVEL DOCUMENTATION
@c PRESERVE THIS DESCRIPTION PENDING FURTHER DECISION
@c @defun pcoeff (poly monom [variables-to-exclude-from-cof (list-variables monom)])
@c
@c This function is called from Lisp level, and uses internal poly format.
@c @example
@c
@c CL-MAXIMA>>(setq me (st-rat #$x^2*u+y+1$))
@c (#:Y 1 1 0 (#:X 2 (#:U 1 1) 0 1))
@c
@c CL-MAXIMA>>(pcoeff me (st-rat #$x^2$))
@c (#:U 1 1)
@c @end example
@c @noindent
@c
@c Rule: if a variable appears in monom it must be to the exact power,
@c and if it is in variables to exclude it may not appear unless it was
@c in monom to the exact power.  (pcoeff pol 1 ..) will exclude variables
@c like substituting them to be zero.
@c
@c @end defun

@c THIS FUNCTION DOESN'T SEEM TO BE APPROPRIATE IN USER-LEVEL DOCUMENTATION
@c PRESERVE THIS DESCRIPTION PENDING FURTHER DECISION
@c @defun new-disrep (poly)
@c
@c From Lisp this returns the general Maxima format for an arg which is
@c in st-rat form:
@c
@c @example
@c (displa(new-disrep (setq me (st-rat #$x^2*u+y+1$))))
@c
@c        2
@c y + u x  + 1
@c @end example
@c
@c @end defun

@defvr {Управляющая переменная} all_dotsimp_denoms
Значение по умолчанию: @code{false}

Когда @code{all_dotsimp_denoms} является списком,то
знаменатели, встречающиеся при работе @code{dotsimp}, добавляются к этому списку.
@code{all_dotsimp_denoms} может быть инициализировано пустым списком @code{[]}
перед вызовом @code{dotsimp}.

По умолчанию @code{dotsimp} не собирает числители.

@opencatbox
@category{Пакет affine}
@closecatbox
@end defvr



