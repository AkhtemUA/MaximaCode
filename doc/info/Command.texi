@menu
* Introduction to Command Line::
* Functions and Variables for Command Line::
@end menu

@c -----------------------------------------------------------------------------
@node Introduction to Command Line, Functions and Variables for Command Line, Command Line, Command Line
@section Introduction to Command Line
@c -----------------------------------------------------------------------------

@c end concepts Command Line

@c -----------------------------------------------------------------------------
@node Functions and Variables for Command Line,  , Introduction to Command Line, Command Line
@section Functions and Variables for Command Line
@c -----------------------------------------------------------------------------

@c -----------------------------------------------------------------------------
@anchor{__}
@defvr {System variable} __
@ifinfo
@vrindex Current input expression
@end ifinfo

@code{__} is the input expression currently being evaluated.  That is, while an
input expression @var{expr} is being evaluated, @code{__} is @var{expr}.

@code{__} is assigned the input expression before the input is simplified or
evaluated.  However, the value of @code{__} is simplified (but not evaluated)
when it is displayed.

@code{__} is recognized by @mref{batch} and @mrefdot{load}  In a file processed
by @code{batch}, @code{__} has the same meaning as at the interactive prompt.
In a file processed by @code{load}, @code{__} is bound to the input expression
most recently entered at the interactive prompt or in a batch file; @code{__}
is not bound to the input expressions in the file being processed.  In
particular, when @code{load (@var{filename})} is called from the interactive
prompt, @code{__} is bound to @code{load (@var{filename})} while the file is
being processed.

See also @mref{_} and @mrefdot{%}

Examples:

@c ===beg===
@c print ("I was called as", __);
@c foo (__);
@c g (x) := (print ("Current input expression =", __), 0);
@c [aa : 1, bb : 2, cc : 3];
@c (aa + bb + cc)/(dd + ee + g(x));
@c ===end===
@example
(%i1) print ("I was called as", __);
I was called as print(I was called as, __) 
(%o1)              print(I was called as, __)
(%i2) foo (__);
(%o2)                     foo(foo(__))
(%i3) g (x) := (print ("Current input expression =", __), 0);
(%o3) g(x) := (print("Current input expression =", __), 0)
(%i4) [aa : 1, bb : 2, cc : 3];
(%o4)                       [1, 2, 3]
(%i5) (aa + bb + cc)/(dd + ee + g(x));
                            cc + bb + aa
Current input expression = -------------- 
                           g(x) + ee + dd
                                6
(%o5)                        -------
                             ee + dd
@end example

@opencatbox
@category{Global variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{_}
@defvr {System variable} _
@ifinfo
@vrindex Previous input
@end ifinfo

@code{_} is the most recent input expression (e.g., @code{%i1}, @code{%i2},
@code{%i3}, @dots{}).

@code{_} is assigned the input expression before the input is simplified or
evaluated.  However, the value of @code{_} is simplified (but not evaluated)
when it is displayed.

@code{_} is recognized by @mref{batch} and @mrefdot{load}  In a file processed
by @code{batch}, @code{_} has the same meaning as at the interactive prompt.
In a file processed by @code{load}, @code{_} is bound to the input expression
most recently evaluated at the interactive prompt or in a batch file; @code{_}
is not bound to the input expressions in the file being processed.

See also @mref{__} and @mrefdot{%}

Examples:

@c ===beg===
@c 13 + 29;
@c :lisp $_
@c _;
@c sin (%pi/2);
@c :lisp $_
@c _;
@c a: 13$
@c b: 29$
@c a + b;
@c :lisp $_
@c _;
@c a + b;
@c ev (_);
@c ===end===
@example
(%i1) 13 + 29;
(%o1)                          42
(%i2) :lisp $_
((MPLUS) 13 29)
(%i2) _;
(%o2)                          42
(%i3) sin (%pi/2);
(%o3)                           1
(%i4) :lisp $_
((%SIN) ((MQUOTIENT) $%PI 2))
(%i4) _;
(%o4)                           1
(%i5) a: 13$
(%i6) b: 29$
(%i7) a + b;
(%o7)                          42
(%i8) :lisp $_
((MPLUS) $A $B)
(%i8) _;
(%o8)                         b + a
(%i9) a + b;
(%o9)                          42
(%i10) ev (_);
(%o10)                         42
@end example

@opencatbox
@category{Console interaction} @category{Global variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{%}
@defvr {System variable} %
@ifinfo
@vrindex Previous output
@end ifinfo

@code{%} is the output expression (e.g., @code{%o1}, @code{%o2}, @code{%o3},
@dots{}) most recently computed by Maxima, whether or not it was displayed.

@code{%} is recognized by @mref{batch} and @mrefdot{load}  In a file processed
by @code{batch}, @code{%} has the same meaning as at the interactive prompt.
In a file processed by @code{load}, @code{%} is bound to the output expression
most recently computed at the interactive prompt or in a batch file; @code{%}
is not bound to output expressions in the file being processed.

See also @mrefcomma{_} @mrefcomma{%%} and @mrefdot{%th}

@opencatbox
@category{Console interaction} @category{Global variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{%%}
@defvr {System variable} %%
@ifinfo
@vrindex Previous result in compound expression
@end ifinfo

In compound statements, namely @mrefcomma{block} @mrefcomma{lambda} or
@code{(@var{s_1}, ..., @var{s_n})}, @code{%%} is the value of the previous
statement.  For example,

@example
block (integrate (x^5, x), ev (%%, x=2) - ev (%%, x=1));
block ([prev], prev: integrate (x^5, x),
               ev (prev, x=2) - ev (prev, x=1));
@end example

yield the same result, namely @code{21/2}.

A compound statement may comprise other compound statements.  Whether a
statement be simple or compound, @code{%%} is the value of the previous
statement.  For example,

@example
block (block (a^n, %%*42), %%/6)
@end example

yields @code{7*a^n}.

Within a compound statement, the value of @code{%%} may be inspected at a break
prompt, which is opened by executing the @mref{break} function.  For example,
at the break prompt opened by

@example
block (a: 42, break ())$
@end example

entering @code{%%;} yields @code{42}.

At the first statement in a compound statement, or outside of a compound
statement, @code{%%} is undefined.

@code{%%} is recognized by @mref{batch} and @mrefcomma{load} and it has the
same meaning as at the interactive prompt.

See also @mrefdot{%}

@opencatbox
@category{Global variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{%th}
@deffn {Function} %th (@var{i})
@ifinfo
@fnindex N'th previous output
@end ifinfo

The value of the @var{i}'th previous output expression.  That is, if the next
expression to be computed is the @var{n}'th output, @code{%th (@var{m})} is the
(@var{n} - @var{m})'th output.

@code{%th} is useful in @code{batch} files or for referring to a group of
output expressions.  For example,

@example
block (s: 0, for i:1 thru 10 do s: s + %th (i))$
@end example

sets @code{s} to the sum of the last ten output expressions.

@code{%th} is recognized by @mref{batch} and @mrefdot{load}  In a file processed
by @code{batch}, @code{%th} has the same meaning as at the interactive prompt.
In a file processed by @code{load}, @code{%th} refers to output expressions most
recently computed at the interactive prompt or in a batch file; @code{%th} does
not refer to output expressions in the file being processed.

See also @mrefdot{%}

@opencatbox
@category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{?}
@deffn {Special symbol} ?
@ifinfo
@fnindex Fetch documentation
@end ifinfo

As prefix to a function or variable name, @code{?} signifies that the name is a
Lisp name, not a Maxima name.  For example, @code{?round} signifies the Lisp
function @code{ROUND}.  See @ref{Lisp and Maxima} for more on this point.

The notation @code{? word} (a question mark followed a word, separated by
whitespace) is equivalent to @code{describe("word")}.  The question mark must
occur at the beginning of an input line; otherwise it is not recognized as a
request for documentation.  See also @mrefdot{describe}

@opencatbox
@category{Help} @category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{??}
@deffn {Special symbol} ??
@ifinfo
@fnindex Fetch documentation (inexact search)
@end ifinfo

The notation @code{?? word} (@code{??} followed a word, separated by whitespace)
is equivalent to @code{describe("word", inexact)}.  The question mark must occur
at the beginning of an input line; otherwise it is not recognized as a request
for documentation.  See also @mrefdot{describe}

@opencatbox
@category{Help} @category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{inchar}
@defvr {Option variable} inchar
Default value: @code{%i}

@code{inchar} is the prefix of the labels of expressions entered by the user.
Maxima automatically constructs a label for each input expression by 
concatenating @code{inchar} and @mrefdot{linenum}

@code{inchar} may be assigned any string or symbol, not necessarily a single 
character.  Because Maxima internally takes into account only the first char of
the prefix, the prefixes @code{inchar}, @mrefcomma{outchar} and
@mref{linechar} should have a different first char.  Otherwise some commands
like @code{kill(inlables)} do not work as expected.

@c ===beg===
@c inchar: "input";
@c expand((a+b)^3);
@c ===end===
@example
(%i1) inchar: "input";
(%o1)                                input
(input1) expand ((a+b)^3);
                            3        2      2      3
(%o1)                      b  + 3 a b  + 3 a  b + a
(input2)
@end example

See also @code{labels}.

@opencatbox
@category{Display flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{infolists}
@defvr {System variable} infolists
Default value: @code{[]}

@code{infolists} is a list of the names of all of the information
lists in Maxima. These are:

@table @code
@item labels
All bound @code{%i}, @code{%o}, and @code{%t} labels.
@item values
All bound atoms which are user variables, not Maxima options or switches,
created by @mref{:} or @mref{::} or functional binding.
@c WHAT IS INTENDED BY "FUNCTIONAL BINDING" HERE ??
@item functions
All user-defined functions, created by @mref{:=} or @mrefdot{define}
@item arrays
All declared and undeclared arrays, created by @code{:}, @code{::}, or
@code{:=}.
@c AREN'T THERE OTHER MEANS OF CREATING ARRAYS ??
@item macros
All user-defined macro functions, created by @mrefdot{::=}
@item myoptions
All options ever reset by the user (whether or not they
are later reset to their default values).
@item rules
All user-defined pattern matching and simplification rules, created
by @mrefcomma{tellsimp} @mrefcomma{tellsimpafter} @mrefcomma{defmatch} or
@mrefdot{defrule}
@item aliases
All atoms which have a user-defined alias, created by the @mrefcomma{alias}@w{}
@mrefcomma{ordergreat} @mref{orderless} functions or by declaring the atom as a
@mref{noun} with @mrefdot{declare}
@item dependencies
All atoms which have functional dependencies, created by the
@mref{depends} or @mref{gradef} functions.
@item gradefs
All functions which have user-defined derivatives, created by the
@mref{gradef} function.
@c UMM, WE REALLY NEED TO BE SPECIFIC -- WHAT DOES "ETC" CONTAIN HERE ??
@item props
All atoms which have any property other than those mentioned above, such as
properties established by @mref{atvalue} or @mref{matchdeclare}, etc.,
as well as properties established in the @mref{declare} function.
@item let_rule_packages
All user-defined @mref{let} rule packages
plus the special package @mrefdot{default_let_rule_package}
(@code{default_let_rule_package} is the name of the rule package used when
one is not explicitly set by the user.)
@end table

@opencatbox
@category{Declarations and inferences} @category{Global variables}
@closecatbox
@end defvr

@c REVIEW FOR ACCURACY AND COMPLETENESS
@c THIS ITEM IS VERY IMPORTANT !!
@c NEEDS EXAMPLES

@c -----------------------------------------------------------------------------
@anchor{kill}
@deffn  {Function} kill (@var{a_1}, @dots{}, @var{a_n})
@deffnx {Function} kill (labels)
@deffnx {Function} kill (inlabels, outlabels, linelabels)
@deffnx {Function} kill (@var{n})
@deffnx {Function} kill ([@var{m}, @var{n}])
@deffnx {Function} kill (values, functions, arrays, @dots{})
@deffnx {Function} kill (all)
@deffnx {Function} kill (allbut (@var{a_1}, @dots{}, @var{a_n}))

Removes all bindings (value, function, array, or rule) from the arguments
@var{a_1}, @dots{}, @var{a_n}.  An argument @var{a_k} may be a symbol or a single
array element.  When @var{a_k} is a single array element, @code{kill} unbinds
that element without affecting any other elements of the array.

Several special arguments are recognized.  Different kinds of arguments
may be combined, e.g., @code{kill (inlabels, functions, allbut (foo, bar))}.

@code{kill (labels)} unbinds all input, output, and intermediate expression
labels created so far.  @code{kill (inlabels)} unbinds only input labels which
begin with the current value of @mrefdot{inchar}  Likewise,
@code{kill (outlabels)} unbinds only output labels which begin with the current
value of @mrefcomma{outchar} and @code{kill (linelabels)} unbinds only
intermediate expression labels which begin with the current value of
@mrefdot{linechar}

@code{kill (@var{n})}, where @var{n} is an integer,
unbinds the @var{n} most recent input and output labels.

@code{kill ([@var{m}, @var{n}])} unbinds input and output labels @var{m} through
@var{n}.

@code{kill (@var{infolist})}, where @var{infolist} is any item in
@code{infolists} (such as @mrefcomma{values} @mrefcomma{functions} or
@mref{arrays}) unbinds all items in @var{infolist}.
See also @mrefdot{infolists}

@code{kill (all)} unbinds all items on all infolists.  @code{kill (all)} does
not reset global variables to their default values; see @mref{reset} on this
point.

@code{kill (allbut (@var{a_1}, ..., @var{a_n}))} unbinds all items on all
infolists except for @var{a_1}, @dots{}, @var{a_n}.
@code{kill (allbut (@var{infolist}))} unbinds all items except for the ones on
@var{infolist}, where @var{infolist} is @mrefcomma{values}@w{}
@mrefcomma{functions} @mrefcomma{arrays} etc.

The memory taken up by a bound property is not released until all symbols are
unbound from it.  In particular, to release the memory taken up by the value of
a symbol, one unbinds the output label which shows the bound value, as well as
unbinding the symbol itself.

@code{kill} quotes its arguments.  The quote-quote operator @code{'@w{}'}
defeats quotation.

@code{kill (@var{symbol})} unbinds all properties of @var{symbol}.  In contrast,
the functions @mrefcomma{remvalue} @mrefcomma{remfunction}@w{}
@mrefcomma{remarray} and @mref{remrule} unbind a specific property.

@code{kill} always returns @code{done}, even if an argument has no binding.

@opencatbox
@category{Evaluation} @category{Console interaction} @category{Session management}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{labels}
@deffn  {Function} labels (@var{symbol})
@deffnx {System variable} labels

Returns the list of input, output, or intermediate expression labels which begin
with @var{symbol}.  Typically @var{symbol} is the value of
@mrefcomma{inchar} @mrefcomma{outchar} or @mrefdot{linechar}  The label
character may be given with or without a percent sign, so, for example, @code{i}
and @code{%i} yield the same result.

If no labels begin with @var{symbol}, @code{labels} returns an empty list.

The function @code{labels} quotes its argument.  The quote-quote operator
@code{'@w{}'} defeats quotation.  For example, @code{labels (''inchar)} returns
the input labels which begin with the current input label character.

The variable @code{labels} is the list of input, output, and intermediate
expression labels, including all previous labels if @code{inchar},
@code{outchar}, or @code{linechar} were redefined.

By default, Maxima displays the result of each user input expression, giving the
result an output label.  The output display is suppressed by terminating the
input with @code{$} (dollar sign) instead of @code{;} (semicolon).  An output
label is constructed and bound to the result, but not displayed, and the label
may be referenced in the same way as displayed output labels.  See also
@mrefcomma{%} @mrefcomma{%%} and @mrefdot{%th}

Intermediate expression labels can be generated by some functions.  The option
variable @mref{programmode} controls whether @mref{solve} and some other
functions generate intermediate expression labels instead of returning a list of
expressions.  Some other functions, such as @mrefcomma{ldisplay} always generate
intermediate expression labels.

See also @mrefcomma{inchar} @mrefcomma{outchar} @mrefcomma{linechar} and
@mrefdot{infolists}

@opencatbox
@category{Display functions} @category{Display flags and variables} @category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{linechar}
@defvr {Option variable} linechar
Default value: @code{%t}

@code{linechar} is the prefix of the labels of intermediate expressions 
generated by Maxima. Maxima constructs a label for each intermediate expression 
(if displayed) by concatenating @code{linechar} and @mrefdot{linenum}

@code{linechar} may be assigned any string or symbol, not necessarily a single 
character. Because Maxima internally takes into account only the first char of
the prefix, the prefixes @mrefcomma{inchar} @mrefcomma{outchar} and
@code{linechar} should have a different first char. Otherwise some commands like
@code{kill(inlables)} do not work as expected.

Intermediate expressions might or might not be displayed.
See @mref{programmode} and @mrefdot{labels}

@opencatbox
@category{Display flags and variables}
@closecatbox
@end defvr

@c EXPAND; SHOW WHAT HAPPENS WHEN linenum IS ASSIGNED A VALUE

@c -----------------------------------------------------------------------------
@anchor{linenum}
@defvr {System variable} linenum

The line number of the current pair of input and output expressions.

@opencatbox
@category{Display flags and variables} @category{Console interaction}
@closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{myoptions}
@defvr {System variable} myoptions
Default value: @code{[]}

@code{myoptions} is the list of all options ever reset by the user,
whether or not they get reset to their default value.

@opencatbox
@category{Global variables} @category{Session management} @category{Console interaction}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{nolabels}
@defvr {Option variable} nolabels
Default value: @code{false}

When @code{nolabels} is @code{true}, input and output result labels (@code{%i}
and @code{%o}, respectively) are displayed, but the labels are not bound to
results, and the labels are not appended to the @mref{labels} list.  Since
labels are not bound to results, garbage collection can recover the memory taken
up by the results.

Otherwise input and output result labels are bound to results, and the labels
are appended to the @code{labels} list.

Intermediate expression labels (@code{%t}) are not affected by @code{nolabels};
whether @code{nolabels} is @code{true} or @code{false}, intermediate expression
labels are bound and appended to the @code{labels} list.

See also @mrefcomma{batch} @mrefcomma{load} and @mrefdot{labels}

@opencatbox
@category{Global flags} @category{Session management}
@closecatbox
@end defvr

@c NEEDS WORK

@c -----------------------------------------------------------------------------
@anchor{optionset}
@defvr {Option variable} optionset
Default value: @code{false}

When @code{optionset} is @code{true}, Maxima prints out a message whenever a
Maxima option is reset.  This is useful if the user is doubtful of the spelling
of some option and wants to make sure that the variable he assigned a value to
was truly an option variable.

@opencatbox
@category{Global flags} @category{Session management} @category{Console interaction}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@need 800
@anchor{outchar}
@defvr {Option variable} outchar
Default value: @code{%o}

@code{outchar} is the prefix of the labels of expressions computed by Maxima.
Maxima automatically constructs a label for each computed expression by 
concatenating @code{outchar} and @mrefdot{linenum}

@code{outchar} may be assigned any string or symbol, not necessarily a single 
character. Because Maxima internally takes into account only the first char of
the prefix, the prefixes @mrefcomma{inchar} @code{outchar} and
@mref{linechar} should have a different first char.  Otherwise some commands
like @code{kill(inlables)} do not work as expected.

@c ===beg===
@c outchar: "output";
@c expand((a+b)^3);
@c ===end===
@example
(%i1) outchar: "output";
(output1)                           output
(%i2) expand ((a+b)^3);
                            3        2      2      3
(output2)                  b  + 3 a b  + 3 a  b + a
(%i3)
@end example

See also @code{labels}.

@opencatbox
@category{Display flags and variables}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{playback}
@deffn  {Function} playback ()
@deffnx {Function} playback (@var{n})
@deffnx {Function} playback ([@var{m}, @var{n}])
@deffnx {Function} playback ([@var{m}])
@deffnx {Function} playback (input)
@deffnx {Function} playback (slow)
@deffnx {Function} playback (time)
@deffnx {Function} playback (grind)

Displays input, output, and intermediate expressions, without recomputing them.
@code{playback} only displays the expressions bound to labels; any other output
(such as text printed by @mref{print} or @mrefcomma{describe} or error messages)
is not displayed.  See also @mrefdot{labels}

@code{playback} quotes its arguments.  The quote-quote operator @code{'@w{}'}
defeats quotation.  @code{playback} always returns @code{done}.

@code{playback ()} (with no arguments) displays all input, output, and
intermediate expressions generated so far.  An output expression is displayed
even if it was suppressed by the @code{$} terminator when it was originally
computed.

@code{playback (@var{n})} displays the most recent @var{n} expressions.
Each input, output, and intermediate expression counts as one.

@code{playback ([@var{m}, @var{n}])} displays input, output, and intermediate
expressions with numbers from @var{m} through @var{n}, inclusive.

@code{playback ([@var{m}])} is equivalent to
@code{playback ([@var{m}, @var{m}])}; this usually prints one pair of input and
output expressions.

@code{playback (input)} displays all input expressions generated so far.

@code{playback (slow)} pauses between expressions and waits for the user to
press @code{enter}.  This behavior is similar to @mrefdot{demo}
@c WHAT DOES THE FOLLOWING MEAN ???
@code{playback (slow)} is useful in conjunction with @code{save} or
@mref{stringout} when creating a secondary-storage file in order to pick out
useful expressions.

@code{playback (time)} displays the computation time for each expression.
@c DON'T BOTHER TO MENTION OBSOLETE OPTIONS !!!
@c The arguments @code{gctime} and @code{totaltime} have the same effect as @code{time}.

@code{playback (grind)} displays input expressions in the same format as the
@code{grind} function.  Output expressions are not affected by the @code{grind}
option.  See @mrefdot{grind}

Arguments may be combined, e.g., @code{playback ([5, 10], grind, time, slow)}.
@c APPEARS TO BE input INTERSECT (UNION OF ALL OTHER ARGUMENTS). CORRECT ???

@opencatbox
@category{Display functions} @category{Console interaction}
@closecatbox
@end deffn

@c NEEDS WORK ESPECIALLY EXAMPLES
@c WHOLE BUSINESS WITH PROPERTIES IS PRETTY CONFUSING, TRY TO CLEAR IT UP

@c -----------------------------------------------------------------------------
@anchor{printprops}
@deffn  {Function} printprops (@var{a}, @var{i})
@deffnx {Function} printprops ([@var{a_1}, @dots{}, @var{a_n}], @var{i})
@deffnx {Function} printprops (all, @var{i})

Displays the property with the indicator @var{i} associated with the atom
@var{a}.  @var{a} may also be a list of atoms or the atom @code{all} in which
case all of the atoms with the given property will be used.  For example,
@code{printprops ([f, g], atvalue)}.  @code{printprops} is for properties that
cannot otherwise be displayed, i.e.  for @mrefcomma{atvalue}@w{}
@mrefcomma{atomgrad} @mrefcomma{gradef} and @mrefdot{matchdeclare}

@opencatbox
@category{Declarations and inferences} @category{Display functions}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@need 800
@anchor{prompt}
@defvr {Option variable} prompt
Default value: @code{_}

@code{prompt} is the prompt symbol of the @mref{demo} function,
@code{playback (slow)} mode, and the Maxima break loop (as invoked by
@mref{break}).

@opencatbox
@category{Global variables} @category{Console interaction}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{quit}
@deffn {Function} quit ()

Terminates the Maxima session.  Note that the function must be invoked as
@code{quit();} or @code{quit()$}, not @code{quit} by itself.

To stop a lengthy computation, type @code{control-C}.  The default action is to
return to the Maxima prompt.  If @code{*debugger-hook*} is @code{nil},
@code{control-C} opens the Lisp debugger.  See also @ref{Debugging}.

@opencatbox
@category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{read}
@deffn {Function} read (@var{expr_1}, @dots{}, @var{expr_n})

Prints @var{expr_1}, @dots{}, @var{expr_n}, then reads one expression from the
console and returns the evaluated expression.  The expression is terminated with
a semicolon @code{;} or dollar sign @code{$}.

See also @mref{readonly}

Example:

@example
(%i1) foo: 42$ 
(%i2) foo: read ("foo is", foo, " -- enter new value.")$
foo is 42  -- enter new value. 
(a+b)^3;
(%i3) foo;
                                     3
(%o3)                         (b + a)
@end example

@opencatbox
@category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{readonly}
@deffn {Function} readonly (@var{expr_1}, @dots{}, @var{expr_n})

Prints @var{expr_1}, @dots{}, @var{expr_n}, then reads one expression from the
console and returns the expression (without evaluation).  The expression is
terminated with a @code{;} (semicolon) or @code{$} (dollar sign).

See also @mrefdot{read}

Examples:

@example
(%i1) aa: 7$
(%i2) foo: readonly ("Enter an expression:");
Enter an expression: 
2^aa;
                                  aa
(%o2)                            2
(%i3) foo: read ("Enter an expression:");
Enter an expression: 
2^aa;
(%o3)                            128
@end example

@opencatbox
@category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{reset}
@deffn {Function} reset ()

Resets many global variables and options, and some other variables, to their
default values.

@code{reset} processes the variables on the Lisp list
@code{*variable-initial-values*}.  The Lisp macro @code{defmvar} puts variables
on this list (among other actions).  Many, but not all, global variables and
options are defined by @code{defmvar}, and some variables defined by
@code{defmvar} are not global variables or options.

@opencatbox
@category{Session management}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{showtime}
@defvr {Option variable} showtime
Default value: @code{false}

When @code{showtime} is @code{true}, the computation time and elapsed time is
printed with each output expression.

The computation time is always recorded, so @mref{time} and @mref{playback} can
display the computation time even when @code{showtime} is @code{false}.

See also @mrefdot{timer}

@opencatbox
@category{Display flags and variables} @category{Debugging}
@closecatbox
@end defvr

@c -----------------------------------------------------------------------------
@anchor{to_lisp}
@deffn {Function} to_lisp ()

Enters the Lisp system under Maxima.  @code{(to-maxima)} returns to Maxima.

Example:

Define a function and enter the Lisp system under Maxima.  The definition is
inspected on the property list, then the function definition is extracted,
factored and stored in the variable $result.  The variable can be used in Maxima
after returning to Maxima.

@example
(%i1) f(x):=x^2+x;
                                  2
(%o1)                    f(x) := x  + x
(%i2) to_lisp();
Type (to-maxima) to restart, ($quit) to quit Maxima.
MAXIMA> (symbol-plist '$f)
(MPROPS (NIL MEXPR ((LAMBDA) ((MLIST) $X) 
                             ((MPLUS) ((MEXPT) $X 2) $X))))
MAXIMA> (setq $result ($factor (caddr (mget '$f 'mexpr))))
((MTIMES SIMP FACTORED) $X ((MPLUS SIMP IRREDUCIBLE) 1 $X))
MAXIMA> (to-maxima)
Returning to Maxima
(%o2)                         true
(%i3) result;
(%o3)                       x (x + 1)
@end example

@opencatbox
@category{Console interaction}
@closecatbox
@end deffn

@c -----------------------------------------------------------------------------
@anchor{values}
@defvr {System variable} values
Initial value: @code{[]}

@code{values} is a list of all bound user variables (not Maxima options or
switches).  The list comprises symbols bound by @mrefcomma{:} or @mrefdot{::}

If the value of a variable is removed with the commands @code{kill}, 
@mrefcomma{remove} or @mref{remvalue} the variable is deleted from
@code{values}.

See @mref{functions} for a list of user defined functions.

Examples:

First, @code{values} shows the symbols @code{a}, @code{b}, and @code{c}, but 
not @code{d}, it is not bound to a value, and not the user function @code{f}.
The values are removed from the variables.  @code{values} is the empty list.

@c ===beg===
@c [a:99, b:: a-90, c:a-b, d, f(x):=x^2];
@c values;
@c [kill(a), remove(b,value), remvalue(c)];
@c values;
@c ===end===
@example
(%i1) [a:99, b::a-90, c:a-b, d, f(x):= x^2];
                                                  2
(%o1)                     [99, 9, 90, d, f(x) := x ]
(%i2) values;
(%o2)                              [a, b, c]
(%i3) [kill(a), remove(b,value), remvalue(c)];
(%o3)                          [done, done, [c]]
(%i4) values;
(%o4)                                 []
@end example

@opencatbox
@category{Evaluation} @category{Global variables}
@closecatbox
@end defvr

