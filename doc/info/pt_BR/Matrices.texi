/Matrices.texi/1.29/Sat Jun  2 00:12:57 2007/-ko/
@c Language: Brazilian Portuguese, Encoding: iso-8859-1
@c /Matrices.texi/1.28/Fri Mar  2 00:44:39 2007/-ko/
@menu
* Introdu@value{cedilha}@~{a}o a Matrizes e @'{A}lgebra Linear::  
* Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Matrizes e @'{A}lgebra Linear::  
@end menu

@node Introdu@value{cedilha}@~{a}o a Matrizes e @'{A}lgebra Linear, Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Matrizes e @'{A}lgebra Linear, Matrizes e @'{A}lgebra Linear, Matrizes e @'{A}lgebra Linear
@section Introdu@value{cedilha}@~{a}o a Matrizes e @'{A}lgebra Linear

@menu
* Ponto::                         
* Vetores::                     
* auto::
@end menu

@node Ponto, Vetores, Introdu@value{cedilha}@~{a}o a Matrizes e @'{A}lgebra Linear, Introdu@value{cedilha}@~{a}o a Matrizes e @'{A}lgebra Linear
@subsection Ponto
O operador @code{.} representa multiplica@value{cedilha}@~{a}o n@~{a}o comutativa e produto escalar.
Quando os operandos s@~{a}o matrizes 1-coluna ou 1-linha @code{a} e @code{b},
a expres@~{a}o @code{a.b} @'{e} equivalente a @code{sum (a[i]*b[i], i, 1, length(a))}.
Se @code{a} e @code{b} n@~{a}o s@~{a}o complexos, isso @'{e} o produto escalar,
tamb@'{e}m chamado produto interno ou produto do ponto, de @code{a} e @code{b}.
O produto escalar @'{e} definido como @code{conjugate(a).b} quando @code{a} e @code{b} s@~{a}o complexos;
@code{innerproduct} no pacote @code{eigen} fornece o produto escalar complexo.

Quando os operandos s@~{a}o matrizes mais gerais,
o produto @'{e} a matriz produto @code{a} e @code{b}.
O n@'{u}mero de linhas de @code{b} deve ser igual ao n@'{u}mero de colunas de @code{a},
e o resultado tem n@'{u}mero de linhas igual ao n@'{u}mero de linhas de @code{a}
e n@'{u}mero de colunas igual ao n@'{u}mero de colunas de @code{b}.

Para disting@"{u}ir @code{.} como um operador aritm@'{e}tico do 
ponto decimal em um n@'{u}mero em ponto flutuante,
pode ser necess@'{a}rio deixar espa@value{cedilha}os em cada lado.
Por exemplo, @code{5.e3} @'{e} @code{5000.0} mas @code{5 . e3} @'{e} @code{5} vezes @code{e3}.

Existem muitos sinalizadores que governam a simplifica@value{cedilha}@~{a}o de
expres@~{o}es envolvendo @code{.}, a saber
@code{dot}, @code{dot0nscsimp}, @code{dot0simp}, @code{dot1simp}, @code{dotassoc}, 
@code{dotconstrules}, @code{dotdistrib}, @code{dotexptsimp}, @code{dotident},
e @code{dotscrules}.

@node Vetores, auto, Ponto, Introdu@value{cedilha}@~{a}o a Matrizes e @'{A}lgebra Linear
@subsection Vetores
@code{vect} @'{e} um pacote de fun@value{cedilha}@~{o}es para an@'{a}lise vetorial.
@code{load ("vect")} chama esse pacote, e @code{demo ("vect")} permite visualizar uma demonstra@value{cedilha}@~{a}o.
@c find maxima -name \*orth\* YIELDS NOTHING; ARE THESE FUNCTIONS IN ANOTHER FILE NOW ??
@c and SHARE;VECT ORTH contains definitions of various orthogonal curvilinear coordinate systems.

O pacote de an@'{a}lise vetorial pode combinar e simplificar expres@~{o}es
simb@'{o}licas incluindo produtos dos pontos e productos dos x, juntamente com
o gradiente, divergencia, tor@value{cedilha}@~{a}o, e operadores Laplacianos.  A 
distribui@value{cedilha}@~{a}o desses operadores sobre adi@value{cedilha}@~{o}es ou produtos @'{e} governada
por muitos sinalizadores, como s@~{a}o v@'{a}rias outras expans@~{o}es, incluindo expans@~{a}o
dentro de componentes em qualquer sistema de coordenadas ortogonais.
Existem tamb@'{e}m fun@value{cedilha}@~{o}es para derivar o escalar ou vetor potencial
de um campo.

O pacote @code{vect} cont@'{e}m essas fun@value{cedilha}@~{o}es:
@code{vectorsimp}, @code{scalefactors},
@code{express}, @code{potential}, e @code{vectorpotential}.
@c REVIEW vect.usg TO ENSURE THAT TEXINFO HAS WHATEVER IS THERE
@c PRINTFILE(VECT,USAGE,SHARE); for details.

Aten@value{cedilha}@~{a}o: o pacote @code{vect} declara o operador ponto @code{.}
como sendo um operador comutativo.

@node auto, , Vetores, Introdu@value{cedilha}@~{a}o a Matrizes e @'{A}lgebra Linear
@subsection auto

O pacote @code{eigen} cont@'{e}m muitas fun@value{cedilha}@~{o}es devotadas para a
computa@value{cedilha}@~{a}o simb@'{o}lica de autovalores e autovetores.
Maxima chama o pacote automaticamente se uma das fun@value{cedilha}@~{o}es
@code{eigenvalues} ou @code{eigenvectors} @'{e} invocada.
O pacote pode ser chamado explicitamente com @code{load ("eigen")}.

@code{demo ("eigen")} mostra uma demonstra@value{cedilha}@~{a}o das compatibilidades
desse pacote.
@code{batch ("eigen")} executa a mesma demonstra@value{cedilha}@~{a}o,
mas sem lembretes de usu@'{a}rio entre sucessivas computa@value{cedilha}@~{o}es.

As fun@value{cedilha}@~{o}es no pacote @code{eigen} s@~{a}o
@code{innerproduct}, @code{unitvector}, @code{columnvector},
@code{gramschmidt}, @code{eigenvalues}, @code{eigenvectors}, @code{uniteigenvectors},
e @code{similaritytransform}.

@c end concepts Matrizes e @'{A}lgebra Linear
@node Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Matrizes e @'{A}lgebra Linear,  , Introdu@value{cedilha}@~{a}o a Matrizes e @'{A}lgebra Linear, Matrizes e @'{A}lgebra Linear
@section Fun@value{cedilha}@~{o}es e Vari@'{a}veis Definidas para Matrizes e @'{A}lgebra Linear

@deffn {Fun@value{cedilha}@~{a}o} addcol (@mvar{M}, @mvar{list_1}, ..., @mvar{list_n})
Anexa a(s) coluna(s) dadas por uma
ou mais listas (ou matrizes) sobre a matriz @mvar{M}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} addrow (@mvar{M}, @mvar{list_1}, ..., @mvar{list_n})
Anexa a(s) linha(s) dadas por uma ou
mais listas (ou matrizes) sobre a matriz @mvar{M}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} adjoint (@mvar{M})
Retorna a matriz adjunta da matriz @mvar{M}.
A matriz adjunta @'{e} a transposta da matriz dos cofatores de @mvar{M}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} augcoefmatrix ([@mvar{eqn_1}, ..., @mvar{eqn_m}], [@mvar{x_1}, ..., @mvar{x_n}])
Retorna a matriz dos coeficientes
aumentada para as vari@'{a}veis @mvar{x_1}, ..., @mvar{x_n} do sistema de equa@value{cedilha}@~{o}es lineares
@mvar{eqn_1}, ..., @mvar{eqn_m}.  Essa @'{e} a matriz dos coeficientes com uma coluna anexada para
os termos independentes em cada equa@value{cedilha}@~{a}o (i.e., esses termos n@~{a}o dependem de
@mvar{x_1}, ..., @mvar{x_n}).

@example
(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} charpoly (@mvar{M}, @mvar{x})
Retorna um polin@^{o}mio caracter@'{i}stico para a matriz @mvar{M}
em rela@value{cedilha}@~{a}o @`a vari@'{a}vel @mvar{x}.  Que @'{e},
@code{determinant (@mvar{M} - diagmatrix (length (@mvar{M}), @mvar{x}))}.

@example
(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} coefmatrix ([@mvar{eqn_1}, ..., @mvar{eqn_m}], [@mvar{x_1}, ..., @mvar{x_n}])
Retorna a matriz dos coeficientes para as
vari@'{a}veis @mvar{x_1}, ..., @mvar{x_n} do sistema de equa@value{cedilha}@~{o}es lineares
@mvar{eqn_1}, ..., @mvar{eqn_m}.

@example
(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} col (@mvar{M}, @mvar{i})
Reorna a @mvar{i}'@'{e}sima coluna da matriz @mvar{M}.
O valor de retorno @'{e} uma matriz.
@c EXAMPLE HERE

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} columnvector (@mvar{L})
@deffnx {Fun@value{cedilha}@~{a}o} covect (@mvar{L})
Retorna uma matriz de uma coluna e @code{length (@mvar{L})} linhas,
contendo os elementos da lista @mvar{L}.

@code{covect} @'{e} um sin@^{o}nimo para @code{columnvector}.

@code{load ("eigen")} chama essa fun@value{cedilha}@~{a}o.

@c FOLLOWING COMMENT PRESERVED.  WHAT DOES THIS MEAN ??
Isso @'{e} @'{u}til se voc@^{e} quer usar partes das sa@'{i}das das
fun@value{cedilha}@~{o}es nesse pacote em c@'{a}lculos matriciais.

Exemplo:

@c HMM, SPURIOUS "redefining the Macsyma function".
@c LEAVE IT HERE SINCE THAT'S WHAT A USER ACTUALLY SEES.
@example
(%i1) load ("eigen")$
Warning - you are redefining the Macsyma function autovalores
Warning - you are redefining the Macsyma function autovetores
(%i2) columnvector ([aa, bb, cc, dd]);
                             [ aa ]
                             [    ]
                             [ bb ]
(%o2)                        [    ]
                             [ cc ]
                             [    ]
                             [ dd ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} conjugate (@mvar{x})
Retorna o conjugado complexo de @mvar{x}.

@c ===beg===
@c declare ([aa, bb], real, cc, complex, ii, imaginary);
@c conjugate (aa + bb*%i);
@c conjugate (cc);
@c conjugate (ii);
@c conjugate (xx + yy);
@c ===end===
@example
(%i1) declare ([aa, bb], real, cc, complex, ii, imaginary);

(%o1)                         done
(%i2) conjugate (aa + bb*%i);

(%o2)                      aa - %i bb
(%i3) conjugate (cc);

(%o3)                     conjugate(cc)
(%i4) conjugate (ii);

(%o4)                         - ii
(%i5) conjugate (xx + yy);

(%o5)             conjugate(yy) + conjugate(xx)
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} copymatrix (@mvar{M})
Retorna uma c@'{o}pia da matriz @mvar{M}.  Esse @'{e} o @'{u}nico
para fazer uma copia separada copiando @mvar{M} elemento a elemento.

Note que uma atribui@value{cedilha}@~{a}o de uma matriz para outra, como em @code{m2: m1},
n@~{a}o copia @code{m1}.
Uma atribui@value{cedilha}@~{a}o @code{m2 [i,j]: x} ou @code{setelmx (x, i, j, m2} tamb@'{e}m modifica @code{m1 [i,j]}.
criando uma c@'{o}pia com @code{copymatrix} e ent@~{a}o usando atribu@value{cedilha}@~{a}o cria uma separada e modificada c@'{o}pia.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} determinant (@mvar{M})
Calcula o determinante de @mvar{M} por um m@'{e}todo similar @`a
elimina@value{cedilha}@~{a}o de Gauss.

@c JUST HOW DOES ratmx AFFECT THE RESULT ??
A forma do resultado depende da escolha
do comutador @code{ratmx}.

@c IS A SPARSE DETERMINANT SOMETHING OTHER THAN THE DETERMINANT OF A SPARSE MATRIX ??
Existe uma rotina especial para calcular
determinantes esparsos que @'{e} chamada quando os comutadores
@code{ratmx} e @code{sparse} s@~{a}o ambos @code{true}.

@c EXAMPLES NEEDED HERE
@end deffn

@defvr {Vari@'{a}vel} detout
Valor padr@~{a}o: @code{false}

Quando @code{detout} @'{e} @code{true}, o determinante de uma
matriz cuja inversa @'{e} calculada @'{e} fatorado fora da inversa.

Para esse comutador ter efeito @code{doallmxops} e @code{doscmxops} deveram ambos serem
@code{false} (veja suas transcri@value{cedilha}@~{o}es).  Alternativamente esses comutadores podem ser
dados para @code{ev} o que faz com que os outros dois sejam escolhidos corretamente.

Exemplo:

@example
(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
@end example
@c THERE'S MORE TO THIS STORY: detout: false$ invert (m); RETURNS THE SAME THING.
@c IT APPEARS THAT doallmxops IS CRUCIAL HERE.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} diagmatrix (@mvar{n}, @mvar{x})
Retorna uma matriz diagonal de tamanho @mvar{n} por @mvar{n} com os
elementos da diagonal todos iguais a @mvar{x}.
@code{diagmatrix (@mvar{n}, 1)} retorna uma matriz identidade (o mesmo que @code{ident (@mvar{n})}).

@mvar{n} deve avaliar para um inteiro, de outra forma @code{diagmatrix} reclama com uma mensagem de erro.

@mvar{x} pode ser qualquer tipo de expres@~{a}o, incluindo outra matriz.
Se @mvar{x} @'{e} uma matriz, isso n@~{a}o @'{e} copiado; todos os elementos da diagonal referem-se @`a mesma inst@^{a}ncia, @mvar{x}.

@c NEED EXAMPLE HERE
@end deffn

@defvr {Vari@'{a}vel} doallmxops
Valor padr@~{a}o: @code{true}

Quando @code{doallmxops} @'{e} @code{true},
@c UMM, WHAT DOES THIS MEAN EXACTLY ??
todas as opera@value{cedilha}@~{o}es relacionadas a matrizes s@~{a}o realizadas.
Quando isso @'{e} @code{false} ent@~{a}o a escolha de
comutadores individuais @code{dot} governam quais opera@value{cedilha}@~{o}es s@~{a}o executadas.

@c NEED EXAMPLES HERE
@end defvr

@defvr {Vari@'{a}vel} domxexpt
Valor padr@~{a}o: @code{true}

Quando @code{domxexpt} @'{e} @code{true},
uma matriz exponencial, @code{exp (@mvar{M})} onde @mvar{M} @'{e} a matriz,
@'{e} interpretada como uma matriz com elementos @code{[i,j} iguais a @code{exp (m[i,j])}.
de outra forma @code{exp (@mvar{M})} avalia para @code{exp (@mvar{ev(M)}}.

@code{domxexpt}
afeta todas as expres@~{o}es da forma @code{@mvar{base}^@mvar{expoente}} onde @mvar{base} @'{e} uma
expres@~{a}o assumida escalar ou constante, e @mvar{expoente} @'{e} uma lista ou
matriz.

Exemplo:

@example
(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
@end example

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} domxmxops
Valor padr@~{a}o: @code{true}

Quando @code{domxmxops} @'{e} @code{true}, todas as opera@value{cedilha}@~{o}es matriz-matriz ou
matriz-lista s@~{a}o realizadas (mas n@~{a}o opera@value{cedilha}@~{o}es
escalar-matriz); se esse comutador @'{e} @code{false} tais opera@value{cedilha}@~{o}es n@~{a}o s@~{a}o.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} domxnctimes
Valor padr@~{a}o: @code{false}

Quando @code{domxnctimes} @'{e} @code{true}, produtos n@~{a}o comutativos de
matrizes s@~{a}o realizados.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dontfactor
Valor padr@~{a}o: @code{[]}

@code{dontfactor} pode ser escolhido para uma lista de vari@'{a}veis em rela@value{cedilha}@~{a}o
a qual fatora@value{cedilha}@~{a}o n@~{a}o @'{e} para ocorrer.  (A lista @'{e} inicialmente vazia.)
Fatora@value{cedilha}@~{a}o tamb@'{e}m n@~{a}o pegar@'{a} lugares com rela@value{cedilha}@~{a}o a quaisquer vari@'{a}veis que
s@~{a}o menos importantes, conforme a hierarqu@'{i}a de vari@'{a}vel assumida para a forma expres@~{a}o racional can@^{o}nica (CRE),
que essas na lista @code{dontfactor}.

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} doscmxops
Valor padr@~{a}o: @code{false}

Quando @code{doscmxops} @'{e} @code{true}, opera@value{cedilha}@~{o}es escalar-matriz s@~{a}o
realizadas.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} doscmxplus
Valor padr@~{a}o: @code{false}

Quando @code{doscmxplus} @'{e} @code{true}, opera@value{cedilha}@~{o}es escalar-matriz retornam
uma matriz resultado.  Esse comutador n@~{a}o @'{e} subsomado sob @code{doallmxops}.
@c IS THIS AN EVALUATION OR A SIMPLIFICATION FLAG ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dot0nscsimp
Valor padr@~{a}o: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
Quando @code{dot0nscsimp} @'{e} @code{true}, um produto n@~{a}o comutativo de zero
e um termo n@~{a}o escalar @'{e} simplificado para um produto comutativo.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dot0simp
Valor padr@~{a}o: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
Quando @code{dot0simp} @'{e} @code{true},
um produto n@~{a}o comutativo de zero e
um termo escalar @'{e} simplificado para um produto n@~{a}o comutativo.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dot1simp
Valor padr@~{a}o: @code{true}

@c WHAT DOES THIS MEAN EXACTLY ??
Quando @code{dot1simp} @'{e} @code{true},
um produto n@~{a}o comutativo de um e
outro termo @'{e} simplificado para um produto comutativo.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dotassoc
Valor padr@~{a}o: @code{true}

Quando @code{dotassoc} @'{e} @code{true}, uma expres@~{a}o @code{(A.B).C} simplifica para
@code{A.(B.C)}.
@c "." MEANS NONCOMMUTATIVE MULTIPLICATION RIGHT ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dotconstrules
Valor padr@~{a}o: @code{true}

Quando @code{dotconstrules} @'{e} @code{true}, um produto n@~{a}o comutativo de uma
constante e outro termo @'{e} simplificado para um produto comutativo.
@c TERMINOLOGY: (1) SWITCH/FLAG/SOME OTHER TERM ?? (2) ASSIGN/SET/TURN ON/SOME OTHER TERM ??
Ativando esse sinalizador efetivamente ativamos @code{dot0simp}, @code{dot0nscsimp}, e
@code{dot1simp} tamb@'{e}m.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dotdistrib
Valor padr@~{a}o: @code{false}

Quando @code{dotdistrib} @'{e} @code{true}, uma expres@~{a}o @code{A.(B + C)} simplifica para @code{A.B + A.C}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dotexptsimp
Valor padr@~{a}o: @code{true}

Quando @code{dotexptsimp} @'{e} @code{true}, uma expres@~{a}o @code{A.A} simplifica para @code{A^^2}.

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dotident
Valor padr@~{a}o: 1

@code{dotident} @'{e} o valor retornado por @code{X^^0}.
@c "RETURNED" ?? IS THIS A SIMPLIFICATION OR AN EVALUATION ??

@c NEED EXAMPLE HERE
@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} dotscrules
Valor padr@~{a}o: @code{false}

Quando @code{dotscrules} @'{e} @code{true}, uma expres@~{a}o @code{A.SC} ou @code{SC.A} simplifica
para @code{SC*A} e @code{A.(SC*B)} simplifica para @code{SC*(A.B)}.
@c HMM, DOES "SC" MEAN "SCALAR" HERE ?? CLARIFY

@c NEED EXAMPLE HERE
@end defvr

@deffn {Fun@value{cedilha}@~{a}o} echelon (@mvar{M})
Retorna a forma escalonada da matriz @mvar{M},
como produzido atrav@'{e}s da elimina@value{cedilha}@~{a}o de Gauss.
A forma escalonada @'{e} calculada de @mvar{M}
por opera@value{cedilha}@~{o}es elementares de linha tais que o primeiro
elemento n@~{a}o zero em cada linha na matriz resultante seja o n@'{u}mero um e os
elementos da coluna abaixo do primeiro n@'{u}mero um em cada linha sejam todos zero.

@code{triangularize} tamb@'{e}m realiza elimina@value{cedilha}@~{a}o de Gaussian,
mas n@~{a}o normaliza o elemento l@'{i}der n@~{a}o nulo em cada linha.

@code{lu_factor} e @code{cholesky} s@~{a}o outras fun@value{cedilha}@~{o}es que retornam matrizes triangularizadas.

@c ===beg===
@c M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
@c echelon (M);
@c ===end===
@example
(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} eigenvalues (@mvar{M})
@deffnx {Fun@value{cedilha}@~{a}o} eivals (@mvar{M})
@c eigen.mac IS AUTOLOADED IF eigenvalues OR eigenvectors IS REFERENCED; EXTEND THAT TO ALL FUNCTIONS ??
@c EACH FUNCTION INTENDED FOR EXTERNAL USE SHOULD HAVE ITS OWN DOCUMENTATION ITEM
Retorna uma lista de duas listas contendo os autovalores da matriz @mvar{M}.
A primeira sublista do valor de retorno @'{e} a lista de autovalores da
matriz, e a segunda sublista @'{e} a lista de
multiplicidade dos autovalores na ordem correspondente.

@code{eivals} @'{e} um sin@^{o}nimo de @code{eigenvalues}.

@code{eigenvalues} chama a fun@value{cedilha}@~{a}o @code{solve} para achar as ra@'{i}zes do
polin@^{o}mio caracter@'{i}stico da matriz.
Algumas vezes @code{solve} pode n@~{a}o estar habilitado a achar as ra@'{i}zes do polin@^{o}mio;
nesse caso algumas outras fun@value{cedilha}@~{o}es nesse
pacote (except @code{innerproduct}, @code{unitvector}, @code{columnvector} e
@code{gramschmidt}) n@~{a}o ir@~{a}o trabalhar.
@c WHICH ONES ARE THE FUNCTIONS WHICH DON'T WORK ??
@c ACTUALLY IT'S MORE IMPORTANT TO LIST THE ONES WHICH DON'T WORK HERE
@c WHAT DOES "will not work" MEAN, ANYWAY ??

Em alguns casos os autovalores achados por @code{solve} podem ser expres@~{o}es complicadas.
(Isso pode acontecer quando @code{solve} retorna uma expres@~{a}o real n@~{a}o trivial
para um autovalor que @'{e} sabidamente real.)
Isso pode ser poss@'{i}vel para simplificar os autovalores usando algumas outras fun@value{cedilha}@~{o}es.
@c WHAT ARE THOSE OTHER FUNCTIONS ??

O pacote @code{eigen.mac} @'{e} chamado automaticamente quando
@code{eigenvalues} ou @code{eigenvectors} @'{e} referenciado.
Se @code{eigen.mac} n@~{a}o tiver sido ainda chamado,
@code{load ("eigen")} chama-o.
Ap@'{o}s ser chamado, todas as fun@value{cedilha}@~{o}es e vari@'{a}veis no pacote estar@~{a}o dispon@'{i}veis.
@c REFER TO OVERVIEW OF PACKAGE (INCLUDING LIST OF FUNCTIONS) HERE

@c NEED EXAMPLES HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} eigenvectors (@mvar{M})
@deffnx {Fun@value{cedilha}@~{a}o} eivects (@mvar{M})
pegam uma matriz @mvar{M} como seu argumento e retorna uma lista
de listas cuja primeira sublista @'{e} a sa@'{i}da de @code{eigenvalues}
e as outras sublistas s@~{a}o os autovetores da
matriz correspondente para esses autovalores respectivamente.

@code{eivects} @'{e} um sin@^{o}nimo para @code{eigenvectors}.

O pacote @code{eigen.mac} @'{e} chamado automaticamente quando
@code{eigenvalues} ou @code{eigenvectors} @'{e} referenciado.
Se @code{eigen.mac} n@~{a}o tiver sido ainda chamado,
@code{load ("eigen")} chama-o.
Ap@'{o}s ser chamado, todas as fun@value{cedilha}@~{o}es e vari@'{a}veis no pacote estar@~{a}o dispon@'{i}veis.

Os sinalizadores que afetam essa fun@value{cedilha}@~{a}o s@~{a}o:

@code{nondiagonalizable} @'{e} escolhido para @code{true} ou @code{false} dependendo de
se a matriz @'{e} n@~{a}o diagonaliz@'{a}vel ou diagonaliz@'{a}vel ap@'{o}s o
retorno de @code{eigenvectors}.

@code{hermitianmatrix} quando @code{true}, faz com que os autovetores
degenerados da matriz Hermitiana sejam ortogonalizados usando o
algor@'{i}tmo de Gram-Schmidt.

@code{knowneigvals} quando @code{true} faz com que o pacote @code{eigen} assumir que os
autovalores da matriz s@~{a}o conhecidos para o usu@'{a}rio e armazenados sob o
nome global @code{listeigvals}.  @code{listeigvals} poder@'{a} ser escolhido para uma lista similar
@`a sa@'{i}da de @code{eigenvalues}.

A fun@value{cedilha}@~{a}o @code{algsys} @'{e} usada aqui para resolver em rela@value{cedilha}@~{a}o aos autovetores.  Algumas vezes se os
autovalores est@~{a}o aus@^{e}ntes, @code{algsys} pode n@~{a}o estar habilitado a achar uma solu@value{cedilha}@~{a}o.
Em alguns casos, isso pode ser poss@'{i}vel para simplificar os autovalores por
primeiro achando e ent@~{a}o usando o comando @code{eigenvalues} e ent@~{a}o usando outras fun@value{cedilha}@~{o}es
para reduzir os autovalores a alguma coisa mais simples.
Continuando a simplifica@value{cedilha}@~{a}o, @code{eigenvectors} pode ser chamada novamente
com o sinalizador @code{knowneigvals} escolhido para @code{true}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ematrix (@mvar{m}, @mvar{n}, @mvar{x}, @mvar{i}, @mvar{j})
Retorna uma matriz @mvar{m} por @mvar{n}, todos os elementos da qual
s@~{a}o zero exceto para o elemento @code{[@mvar{i}, @mvar{j}]} que @'{e} @mvar{x}.
@c WOW, THAT SEEMS PRETTY SPECIALIZED ...

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} entermatrix (@mvar{m}, @mvar{n})
Retorna uma matriz @mvar{m} por @mvar{n}, lendo os elementos interativamente.

Se @mvar{n} @'{e} igual a @mvar{m},
Maxima pergunta pelo tipo de matriz (diagonal, sim@'{e}trica, antisim@'{e}trica, ou gen@'{e}rica)
e por cada elemento.
Cada resposta @'{e} terminada por um ponto e v@'{i}rgula @code{;} ou sinal de d@'{o}lar @code{$}.

Se @mvar{n} n@~{a}o @'{e} igual a @mvar{m},
Maxima pergunta por cada elemento.

Os elementos podem ser quaisquer express@~{o}es, que s@~{a}o avaliadas.
@code{entermatrix} avalia seus argumentos.

@example
(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matriz  1.  Diagonal  2.  Symmetric  3.  Antisymmetric  4.  General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matriz entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} genmatrix (@mvar{a}, @mvar{i_2}, @mvar{j_2}, @mvar{i_1}, @mvar{j_1})
@deffnx {Fun@value{cedilha}@~{a}o} genmatrix (@mvar{a}, @mvar{i_2}, @mvar{j_2}, @mvar{i_1})
@deffnx {Fun@value{cedilha}@~{a}o} genmatrix (@mvar{a}, @mvar{i_2}, @mvar{j_2})
Retorna uma matriz gerada de @mvar{a},
pegando o elemento @code{@mvar{a}[@mvar{i_1},@mvar{j_1}]}
como o elemento do canto superior esquerdo e @code{@mvar{a}[@mvar{i_2},@mvar{j_2}]}
como o elemento do canto inferior direto da matriz.
Aqui @mvar{a} @'{e} um array declarado (criado atrav@'{e}s de @code{array} mas n@~{a}o por meio de @code{make_array})
ou um array n@~{a}o declarado,
ou uma fun@value{cedilha}@~{a}o array,
ou uma express@~{a}o lambda de dois argumentos.
(Uma fun@value{cedilha}@~{a}O array @'{e} criado como outras fun@value{cedilha}@~{o}es com @code{:=} ou @code{define},
mas os argumentos s@~{a}o colocados entre colch@^{e}tes em lugar de par@^{e}ntesis.)

Se @mvar{j_1} @'{e} omitido, isso @'{e} assumido ser igual a @mvar{i_1}.
Se ambos @mvar{j_1} e @mvar{i_1} s@~{a}o omitidos, ambos s@~{a}o assumidos iguais a 1.

Se um elemento selecionado @code{i,j} de um array for indefinido,
a matriz conter@'{a} um elemento simb@'{o}lico @code{@mvar{a}[i,j]}.

Exemplos:

@c ===beg===
@c h [i, j] := 1 / (i + j - 1);
@c genmatrix (h, 3, 3);
@c array (a, fixnum, 2, 2);
@c a [1, 1] : %e;
@c a [2, 2] : %pi;
@c genmatrix (a, 2, 2);
@c genmatrix (lambda ([i, j], j - i), 3, 3);
@c genmatrix (B, 2, 2);
@c ===end===
@example
(%i1) h [i, j] := 1 / (i + j - 1);
                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} gramschmidt (@mvar{x})
@deffnx {Fun@value{cedilha}@~{a}o} gschmit (@mvar{x})
Realiza o algor@'{i}tmo de ortonaliza@value{cedilha}@~{a}o de Gram-Schmidt sobre @mvar{x},
seja ela uma matriz ou uma lista de listas.
@mvar{x} n@~{a}o @'{e} modificado por @code{gramschmidt}.

Se @mvar{x} @'{e} uma matriz, o algor@'{i}tmo @'{e} aplicado para as linhas de @mvar{x}.
Se @mvar{x} @'{e} uma lista de listas, o algor@'{i}tmo @'{e} aplicado @`as sublistas,
que devem ter igual n@'{u}meros de elementos.
Nos dois casos,
o valor de retorno @'{e} uma lista de listas, as sublistas das listas s@~{a}o ortogonais
e gera o mesmo spa@value{cedilha}o que @mvar{x}.
Se a dimens@~{a}o do conjunto gerador de @mvar{x} @'{e} menor que o n@'{u}mero de linhas ou sublistas,
algumas sublistas do valor de retorno s@~{a}o zero.

@code{factor} @'{e} chamada a cada est@'{a}gio do algor@'{i}tmo para simplificar resultados intermedi@'{a}rios.
Como uma conseq@"{u}@^{e}ncia, o valor de retorno pode conter inteiros fatorados.

@code{gschmit} (nota ortogr@'{a}fica) @'{e} um sin@^{o}nimo para @code{gramschmidt}.

@code{load ("eigen")} chama essa fun@value{cedilha}@~{a}o.

Exemplo:

@example
(%i1) load ("eigen")$
Warning - you are redefining the Macsyma function autovalores
Warning - you are redefining the Macsyma function autovetores
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) i: innerproduct$
(%i5) [i (y[1], y[2]), i (y[2], y[3]), i (y[3], y[1])];
(%o5)                       [0, 0, 0]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ident (@mvar{n})
Retorna uma matriz identidade @mvar{n} por @mvar{n}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} innerproduct (@mvar{x}, @mvar{y})
@deffnx {Fun@value{cedilha}@~{a}o} inprod (@mvar{x}, @mvar{y})
Retorna o produto interno (tamb@'{e}m chamado produto escalar ou produto do ponto) de @mvar{x} e @mvar{y},
que s@~{a}o listas de igual comprimento, ou ambas matrizes 1-coluna ou 1-linha de igual comprimento.
O valor de retorno @'{e} @code{conjugate (x) . y},
onde @code{.} @'{e} o operador de multiplica@value{cedilha}@~{a}o n@~{a}o comutativa.

@code{load ("eigen")} chama essa fun@value{cedilha}@~{a}o.

@code{inprod} @'{e} um sin@^{o}nimo para @code{innerproduct}.

@c NEED EXAMPLE HERE
@end deffn

@c THIS DESCRIPTION NEEDS WORK
@deffn {Fun@value{cedilha}@~{a}o} invert (@mvar{M})
Retorna a inversa da matriz @mvar{M}.
A inversa @'{e} calculada pelo m@'{e}todo adjunto.

Isso permite a um usu@'{a}rio calcular a inversa de uma matriz com
entradas bfloat ou polin@^{o}mios com coeficientes em ponto flutuante sem
converter para a forma CRE.

Cofatores s@~{a}o calculados pela fun@value{cedilha}@~{a}o  @code{determinant},
ent@~{a}o se @code{ratmx} @'{e} @code{false} a inversa @'{e} calculada
sem mudar a representa@value{cedilha}@~{a}o dos elementos.

A implementa@value{cedilha}@~{a}o
corrente @'{e} ineficiente para matrizes de alta ordem.

Quando @code{detout} @'{e} @code{true}, o determinante @'{e} fatorado fora da
inversa.

Os elementos da inversa n@~{a}o s@~{a}o automaticamente expandidos.
Se @mvar{M} tem elementos polinomiais, melhor apar@^{e}ncia de sa@'{i}da pode ser
gerada por @code{expand (invert (m)), detout}.
Se isso @'{e} desej@'{a}vel para ela
divis@~{a}o at@'{e} pelo determinante pode ser excelente por @code{xthru (%)}
ou alternativamente na unha por

@example
expe (adjoint (m)) / expand (determinant (m))
invert (m) := adjoint (m) / determinant (m)
@end example

Veja @code{^^} (expoente n@~{a}o comutativo) para outro m@'{e}todo de inverter uma matriz.

@c NEED EXAMPLE HERE
@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} lmxchar
Valor padr@~{a}o: @code{[}

@code{lmxchar} @'{e} o caractere mostrado como o delimitador
esquerdo de uma matriz.
Veja tamb@'{e}m @code{rmxchar}.

Exemplo:

@example
(%i1) lmxchar: "|"$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
@end example

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} matrix (@mvar{row_1}, ..., @mvar{row_n})
Retorna uma matriz retangular que tem as linhas @mvar{row_1}, ..., @mvar{row_n}.
Cada linha @'{e} uma lista de express@~{o}es.
Todas as linhas devem ter o mesmo comprimento.

As opera@value{cedilha}@~{o}es @code{+} (adi@value{cedilha}@~{a}o), @code{-} (subtra@value{cedilha}@~{a}o), @code{*} (multiplica@value{cedilha}@~{a}o),
e @code{/} (divis@~{a}o), s@~{a}o realizadas elemento por elemento
quando os operandos s@~{a}o duas matrizes, um escalar e uma matriz, ou uma matriz e um escalar.
A opera@value{cedilha}@~{a}o @code{^} (exponencia@value{cedilha}@~{a}o, equivalentemente @code{**})
@'{e} realizada elemento por elemento
se os operandos s@~{a}o um escalar e uma matriz ou uma matriz e um escalar,
mas n@~{a}o se os operandos forem duas matrizes.
@c WHAT DOES THIS NEXT PHRASE MEAN EXACTLY ??
Todos as opera@value{cedilha}@~{o}es s@~{a}o normalmente realizadas de forma completa,
incluindo @code{.} (multiplica@value{cedilha}@~{a}o n@~{a}o comutativa).

Multiplica@value{cedilha}@~{a}o de matrizes @'{e} representada pelo operador de multiplica@value{cedilha}@~{a}o n@~{a}o comutativa @code{.}.
O correspondente operador de exponencia@value{cedilha}@~{a}o n@~{a}o comutativa @'{e} @code{^^}.
Para uma matriz @code{@mvar{A}}, @code{@mvar{A}.@mvar{A} = @mvar{A}^^2} e
@code{@mvar{A}^^-1} @'{e} a inversa de @mvar{A}, se existir.

Existem comutadores para controlar a simplifica@value{cedilha}@~{a}o de expres@~{o}es
envolvendo opera@value{cedilha}@~{o}es escalar e matriz-lista.
S@~{a}o eles
@code{doallmxops}, @code{domxexpt}
@code{domxmxops}, @code{doscmxops}, e @code{doscmxplus}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Existem op@value{cedilha}@~{o}es adicionais que s@~{a}o relacionadas a matrizes.  S@~{a}o elas:
@code{lmxchar}, @code{rmxchar}, @code{ratmx}, @code{listarith}, @code{detout},
@code{scalarmatrix},
e @code{sparse}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Existe um n@'{u}mero de
fun@value{cedilha}@~{o}es que pegam matrizes como argumentos ou devolvem matrizes como valor de retorno.
Veja @code{eigenvalues}, @code{eigenvectors},
@code{determinant},
@code{charpoly}, @code{genmatrix}, @code{addcol}, @code{addrow}, 
@code{copymatrix}, @code{transpose}, @code{echelon},
e @code{rank}.
@c CHECK -- WE PROBABLY WANT EXHAUSTIVE LIST HERE

Exemplos:

@itemize @bullet
@item
Constru@value{cedilha}@~{a}o de matrizes de listas.
@end itemize
@example
(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
@end example
@itemize @bullet
@item
Adi@value{cedilha}@~{a}o, elemento por elemento.
@end itemize
@example
(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
@end example
@itemize @bullet
@item
Subtra@value{cedilha}@~{a}o, elemento por elemento.
@end itemize
@example
(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
@end example
@itemize @bullet
@item
Multiplica@value{cedilha}@~{a}o, elemento por elemento.
@end itemize
@example
(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
@end example
@itemize @bullet
@item
Divis@~{a}o, elemento por elemento.
@end itemize
@example
(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
@end example
@itemize @bullet
@item
Matriz para um expoente escalar, elemento por elemento.
@end itemize
@example
(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
@end example
@itemize @bullet
@item
Base escalar para um expoente matriz, elemento por elemento.
@end itemize
@example
(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example
@itemize @bullet
@item
Base matriz para um expoente matriz.  Essa n@~{a}o @'{e} realizada elemento por elemento.
@c WHAT IS THIS ??
@end itemize
@example
(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
@end example
@itemize @bullet
@item
Multiplica@value{cedilha}@~{a}o n@~{a}o comutativa de matrizes.
@end itemize
@example
(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
@end example
@itemize @bullet
@item
Exponencia@value{cedilha}@~{a}o n@~{a}o comutativa de matrizes.
Uma base escalar @mvar{b} para uma pot@^{e}ncia matriz @mvar{M}
@'{e} realizada elemento por elemento e ent@~{a}o @code{b^^m} @'{e} o mesmo que @code{b^m}.
@end itemize
@example
(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
@end example
@itemize @bullet
@item
A matriz elevada a um expoente -1 com exponencia@value{cedilha}@~{a}o n@~{a}o comutativa @'{e} a matriz inversa,
se existir.
@end itemize
@example
(%i14) x ^^ -1;
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} matrixmap (@mvar{f}, @mvar{M})
Retorna uma matriz com elemento @code{i,j} igual a @code{@mvar{f}(@mvar{M}[i,j])}.

Veja tamb@'{e}m @code{map}, @code{fullmap}, @code{fullmapl}, e @code{apply}.

@c NEED EXAMPLE HERE
@end deffn

@deffn {Fun@value{cedilha}@~{a}o} matrixp (@mvar{expr})
Retorna @code{true} se @mvar{expr} @'{e} uma matriz, de outra forma retorna @code{false}.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} matrix_element_add
Valor padr@~{a}o: @code{+}

@code{matrix_element_add} @'{e} a opera@value{cedilha}@~{a}o 
invocada em lugar da adi@value{cedilha}@~{a}o em uma multiplica@value{cedilha}@~{a}o de matrizes.
A @code{matrix_element_add} pode ser atribu@'{i}do qualquer operador n-@'{a}rio
(que @'{e}, uma fun@value{cedilha}@~{a}o que manuseia qualquer n@'{u}mero de argumentos).
Os valores atribu@'{i}dos podem ser o nome de um operador entre aspas duplas,
o nome da fun@value{cedilha}@~{a}o,
ou uma express@~{a}o lambda.

Veja tamb@'{e}m @code{matrix_element_mult} e @code{matrix_element_transpose}.

Exemplo:

@example
(%i1) matrix_element_add: "*"$
(%i2) matrix_element_mult: "^"$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
@end example

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} matrix_element_mult
Valor padr@~{a}o: @code{*}

@code{matrix_element_mult} @'{e} a opera@value{cedilha}@~{a}o
invocada em lugar da multiplica@value{cedilha}@~{a}o em uma multiplica@value{cedilha}@~{a}o de matrizes.
A @code{matrix_element_mult} pode ser atribu@'{i}do qualquer operador bin@'{a}rio.
O valor atribu@'{i}do pode ser o nome de um operador entre aspas duplas,
o nome de uma fun@value{cedilha}@~{a}o,
ou uma express@~{a}o lambda.

O operador do ponto @code{.} @'{e} uma escolha @'{u}til em alguns contextos.

Veja tamb@'{e}m @code{matrix_element_add} e @code{matrix_element_transpose}.

Exemplo:

@example
(%i1) matrix_element_add: lambda ([[x]], sqrt (apply ("+", x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
@end example

@end defvr

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} matrix_element_transpose
Valor padr@~{a}o: @code{false}

@code{matrix_element_transpose} @'{e} a opera@value{cedilha}@~{a}o
aplicada a cada elemento de uma matriz quando for uma transposta.
A @code{matrix_element_mult} pode ser atribu@'{i}do qualquer operador un@'{a}rio.
O valor atribu@'{i}do pode ser  nome de um operador entre aspas duplas,
o nome de uma fun@value{cedilha}@~{a}o,
ou uma express@~{a}o lambda.

Quando @code{matrix_element_transpose} for igual a @code{transpose},
a fun@value{cedilha}@~{a}o  @code{transpose} @'{e} aplicada a todo elemento.
Quando @code{matrix_element_transpose} for igual a @code{nonscalars},
a fun@value{cedilha}@~{a}o @code{transpose} @'{e} aplicada a todo elemento n@~{a}o escalar.
Se algum elemento @'{e} um @'{a}tomo, a op@value{cedilha}@~{a}o @code{nonscalars} aplica
@code{transpose} somente se o @'{a}tomo for declarado n@~{a}o escalar,
enquanto a op@value{cedilha}@~{a}o @code{transpose} sempre aplica @code{transpose}.

O valor padr@~{a}o, @code{false}, significa nenhuma opera@value{cedilha}@~{a}o @'{e} aplicada.

Veja tamb@'{e}m @code{matrix_element_add} e @code{matrix_element_mult}.

Exemplos:

@example
(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: lambda ([x], realpart(x) - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
@end example

@end defvr

@c IS THIS THE ONLY MATRIX TRACE FUNCTION ??
@deffn {Fun@value{cedilha}@~{a}o} mattrace (@mvar{M})
Retorna o tra@value{cedilha}o (que @'{e}, a soma dos elementos sobre a diagonal principal) da
matriz quadrada @mvar{M}.  

@code{mattrace} @'{e} chamada por @code{ncharpoly},
uma alternativa para @code{charpoly} do Maxima.
@c UMM, HOW IS THAT RELEVANT HERE ??

@code{load ("nchrpl")} chama essa fun@value{cedilha}@~{a}o.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} minor (@mvar{M}, @mvar{i}, @mvar{j})
Retorna o @mvar{i}, @mvar{j} menor do elemento localizado na linha @mvar{i} coluna @mvar{j} da matriz @mvar{M}.  Que @'{e} @mvar{M}
com linha @mvar{i} e coluna @mvar{j} ambas removidas.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ncexpt (@mvar{a}, @mvar{b})
Se uma express@~{a}o exponencial n@~{a}o comutativa @'{e} muito
alta para ser mostrada como @code{@mvar{a}^^@mvar{b}} aparecer@'{a} como @code{ncexpt (@mvar{a},@mvar{b})}.

@code{ncexpt} n@~{a}o @'{e} o nome de uma fun@value{cedilha}@~{a}o ou operador;
o nome somente aparece em sa@'{i}das, e n@~{a}o @'{e} reconhecido em entradas.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} ncharpoly (@mvar{M}, @mvar{x})
Retorna o polin@^{o}mio caracter@'{i}stico da matriz @mvar{M}
com rela@value{cedilha}@~{a}o a @mvar{x}.  Essa @'{e} uma alternativa para @code{charpoly} do Maxima.

@code{ncharpoly} trabalha pelo c@'{a}lculo dos tra@value{cedilha}os das pot@^{e}ncias na dada matriz,
que s@~{a}o sabidos serem iguais a somas de pot@^{e}ncias das ra@'{i}zes do
polin@^{o}mio caracter@'{i}stico.  Para essas quantidade a fun@value{cedilha}@~{a}o
sim@'{e}trica das ra@'{i}zes pode ser calculada, que nada mais s@~{a}o que
os coeficientes do polin@^{o}mio caracter@'{i}stico.  @code{charpoly} trabalha
@c SHOULD THAT BE "m" INSTEAD OF "a" IN THE NEXT LINE ??
formatando o determinante de @code{@mvar{x} * ident [n] - a}.  Dessa forma @code{ncharpoly} @'{e} vencedor,
por exemplo, no caso de largas e densas matrizes preencidas com inteiros,
desde que isso evite inteiramente a aritm@'{e}tica polinomial.

@code{load ("nchrpl")} loads this file.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} newdet (@mvar{M}, @mvar{n})
Calcula o determinante de uma matriz ou array @mvar{M} pelo
algor@'{i}tmo da @'{a}rvore menor de Johnson-Gentleman.
@c UGH -- ARRAYS ARE SUCH A MESS
O argumento @mvar{n} @'{e} a ordem; isso @'{e} opcional se @mvar{M} for uma matriz.

@end deffn

@c NEEDS CLARIFICATION AND EXAMPLES
@defvr {Declara@value{cedilha}@~{a}o} nonscalar
Faz @'{a}tomos ser comportarem da mesma forma que uma lista ou matriz em rela@value{cedilha}@~{a}o ao
operador do ponto.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} nonscalarp (@mvar{expr})
Retorna @code{true} se @mvar{expr} @'{e} um n@~{a}o escalar, i.e., isso cont@'{e}m
@'{a}tomos declarados como n@~{a}o escalares, listas, ou matrizes.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} permanent (@mvar{M}, @mvar{n})
Calcula o permanente da matriz @mvar{M}.  Um permanente
@'{e} como um determinante mas sem mudan@value{cedilha}a de sinal.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} rank (@mvar{M})
Calcula o posto da matriz @mvar{M}.  Que @'{e}, a ordem do
mais largo determinante n@~{a}o singular de @mvar{M}.

@c STATEMENT NEEDS CLARIFICATION
@mvar{rank} pode retornar uma
resposta ruim se n@~{a}o puder determinar que um elemento da matriz que @'{e}
equivalente a zero @'{e} realmente isso.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} ratmx
Valor padr@~{a}o: @code{false}

Quando @code{ratmx} @'{e} @code{false}, adi@value{cedilha}@~{a}o, subtra@value{cedilha}@~{a}o,
e multiplica@value{cedilha}@~{a}o para determinantes e matrizes s@~{a}o executados na
representa@value{cedilha}@~{a}o dos elementos da matriz e fazem com que o resultado da
invers@~{a}o de matrizes seja esquerdo na representa@value{cedilha}@~{a}o geral.

Quando @code{ratmx} @'{e} @code{true},
as 4 opera@value{cedilha}@~{o}es mencionadas acima s@~{a}o executadas na forma CRE e o
resultado da matriz inversa @'{e} dado na forma CRE.  Note isso pode
fazer com que os elementos sejam expandidos (dependendo da escolha de @code{ratfac})
o que pode n@~{a}o ser desejado sempre.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} row (@mvar{M}, @mvar{i})
retorna a @mvar{i}'@'{e}sima linha da matriz @mvar{M}.
O valor de retorno @'{e} uma matriz.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} scalarmatrixp
Valor padr@~{a}o: @code{true}

Quando @code{scalarmatrixp} @'{e} @code{true}, ent@~{a}o sempre que uma matriz 1 x 1
@'{e} produzida como um resultado de c@'{a}lculos o produto do ponto de matrizes 
@'{e} simplificado para um escalar, a saber o elemento solit@'{a}rio da matriz.

Quando @code{scalarmatrixp} @'{e} @code{all},
ent@~{a}o todas as matrizes 1 x 1 ser@~{a}o simplificadas para escalares.

Quando @code{scalarmatrixp} @'{e} @code{false}, matrizes 1 x 1 n@~{a}o s@~{a}o simplificadas para escalares.

@end defvr

@c I WONDER WHAT THIS IS ABOUT
@deffn {Fun@value{cedilha}@~{a}o} scalefactors (@mvar{coordinatetransform})
Aqui coordinatetransform
avalia para a forma [[expres@~{a}o1, expres@~{a}o2, ...],
indetermina@value{cedilha}@~{a}o1, indetermina@value{cedilha}@~{a}o2, ...], onde indetermina@value{cedilha}@~{a}o1,
indetermina@value{cedilha}@~{a}o2, etc.  s@~{a}o as vari@'{a}veis de coordenadas curvil@'{i}neas e
onde a escolha de componentes cartesianas retangulares @'{e} dada em termos das
coordenadas curvil@'{i}neas por [expres@~{a}o1, expres@~{a}o2, ...].
@code{coordinates} @'{e} escolhida para o vetor [indetermina@value{cedilha}@~{a}o1, indetermina@value{cedilha}@~{a}o2,...],
e @code{dimension} @'{e} escolhida para o comprimento desse vetor.  SF[1], SF[2],
..., SF[DIMENSION] s@~{a}o escohidos para fatores de escala de coordenada, e @code{sfprod}
@'{e} escohido para o produto desse fatores de escala.  Inicialmente, @code{coordinates}
@'{e} [X, Y, Z], @code{dimension} @'{e} 3, e SF[1]=SF[2]=SF[3]=SFPROD=1,
correspondendo a coordenadas Cartesianas retangulares 3-dimensional.
Para expandir uma expres@~{a}o dentro de componentes f@'{i}sicos no sistema de coordenadas
corrente , existe uma fun@value{cedilha}@~{a}o com uso da forma
@c SOME TEXT HAS GONE MISSING HERE

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} setelmx (@mvar{x}, @mvar{i}, @mvar{j}, @mvar{M})
Atribue @mvar{x} para o (@mvar{i}, @mvar{j})'@'{e}simo elemento da matriz @mvar{M},
e retorna a matriz alterada.

@code{@mvar{M} [@mvar{i}, @mvar{j}]: @mvar{x}} tem o mesmo efeito,
mas retorna @mvar{x} em lugar de @mvar{M}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} similaritytransform (@mvar{M})
@deffnx {Fun@value{cedilha}@~{a}o} simtran (@mvar{M})
@code{similaritytransform} calcula uma transforma@value{cedilha}@~{a}o homot@'{e}tica da matriz @code{M}.
Isso retorna uma lista que @'{e} a sa@'{i}da do
comando @code{uniteigenvectors}.  Em adi@value{cedilha}@~{a}o se o sinalizador @code{nondiagonalizable}
@'{e} @code{false} duas matrizes globais @code{leftmatrix} e @code{rightmatrix} s@~{a}o calculadas.
Essas matrizes possuem a propriedade de
@code{leftmatrix . @mvar{M} . rightmatrix} @'{e} uma matriz diagonal com os autovalores
de @mvar{M} sobre a diagonal.  Se @code{nondiagonalizable} @'{e} @code{true} as matrizes esquerda e
direita n@~{a}o s@~{a}o computadas.

Se o sinalizador @code{hermitianmatrix} @'{e} @code{true}
ent@~{a}o @code{leftmatrix} @'{e} o conjugado complexo da transposta de
@code{rightmatrix}.  De outra forma @code{leftmatrix} @'{e} a inversa de @code{rightmatrix}.

@code{rightmatrix} @'{e} a matriz cujas colunas s@~{a}o os autovetores
unit@'{a}rios de @mvar{M}.  Os outros sinalizadores (veja @code{eigenvalues} e
@code{eigenvectors}) possuem o mesmo efeito desde que
@code{similaritytransform} chama as outras fun@value{cedilha}@~{o}es no pacote com o objetivo de
estar habilitado para a forma @code{rightmatrix}.

@code{load ("eigen")} chama essa fun@value{cedilha}@~{a}o.

@code{simtran} @'{e} um sin@^{o}nimo para @code{similaritytransform}.

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} sparse
Valor padr@~{a}o: @code{false}

Quando @code{sparse} @'{e} @code{true}, e se @code{ratmx} @'{e} @code{true}, ent@~{a}o @code{determinant}
usar@'{a} rotinas especiais para calcular determinantes esparsos.

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} submatrix (@mvar{i_1}, ..., @mvar{i_m}, @mvar{M}, @mvar{j_1}, ..., @mvar{j_n})
@deffnx {Fun@value{cedilha}@~{a}o} submatrix (@mvar{i_1}, ..., @mvar{i_m}, @mvar{M})
@deffnx {Fun@value{cedilha}@~{a}o} submatrix (@mvar{M}, @mvar{j_1}, ..., @mvar{j_n})
Retorna uma nova matriz formada pela
matrix @mvar{M} com linhas @mvar{i_1}, ..., @mvar{i_m} exclu@'{i}das, e colunas @mvar{j_1}, ..., @mvar{j_n} exclu@'{i}das.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} transpose (@mvar{M})
Retorna a transposta de @mvar{M}.

Se @mvar{M} @'{e} uma matriz, o valor de retorno @'{e} outra matriz @mvar{N}
tal que @code{N[i,j] = M[j,i]}.

Se @mvar{M} for uma lista, o valor de retorno @'{e} uma matrix @mvar{N}
de @code{length (m)} linhas e 1 coluna, tal que @code{N[i,1] = M[i]}.

De outra forma @mvar{M} @'{e} um s@'{i}mbolo,
e o valor de retorno @'{e} uma express@~{a}o substantiva @code{'transpose (@mvar{M})}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} triangularize (@mvar{M})
Retorna a maior forma triangular da matriz @code{M}, como produzido atrav@'{e}s da elimina@value{cedilha}@~{a}o de Gauss.
O valor de retorno @'{e} o mesmo que @code{echelon},
exceto que o o coeficiente lider n@~{a}o nulo em cada linha n@~{a}o @'{e} normalizado para 1.

@code{lu_factor} e @code{cholesky} s@~{a}o outras fun@value{cedilha}@~{o}es que retornam matrizes triangularizadas.

@c ===beg===
@c M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
@c triangularize (M);
@c ===end===
@example
(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
@end example

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} uniteigenvectors (@mvar{M})
@deffnx {Fun@value{cedilha}@~{a}o} ueivects (@mvar{M})
Calcula autovetores unit@'{a}rios da matriz @mvar{M}.
O valor de retorno @'{e} uma lista de listas, a primeiro sublista @'{e} a
sa@'{i}da do comando @code{eigenvalues}, e as outras sublistas s@~{a}o
os autovetores unit@'{a}rios da matriz correspondente a esses autovalores
respectivamente.

@c COPY DESCRIPTIONS OF THOSE FLAGS HERE
Os sinalizadores mencionados na descri@value{cedilha}@~{a}o do
comando @code{eigenvectors} possuem o mesmo efeito aqui tamb@'{e}m.

Quando @code{knowneigvects} @'{e} @code{true}, o pacote @code{eigen} assume
que os autovetores da matriz s@~{a}o conhecidos para o usu@'{a}rio s@~{a}o
armazenados sob o nome global @code{listeigvects}.  @code{listeigvects} pode ser ecolhido
para uma lista similar @`a sa@'{i}da do comando @code{eigenvectors}.

@c FOLLOWING PARAGRAPH IS IN NEED OF SERIOUS CLARIFICATION
Se @code{knowneigvects} @'{e} escolhido para @code{true} e a lista de autovetores @'{e} dada a
escolha do sinalizador @code{nondiagonalizable} pode n@~{a}o estar correta.  Se esse @'{e}
o caso por favor ecolha isso para o valor correto.  O autor assume que
o usu@'{a}rio sabe o que est@'{a} fazendo e que n@~{a}o tentar@'{a} diagonalizar uma
matriz cujos autovetores n@~{a}o geram o mesmo espa@value{cedilha}o vetorial de
dimens@~{a}o apropriada.

@code{load ("eigen")} chama essa fun@value{cedilha}@~{a}o.

@code{ueivects} @'{e} um sin@^{o}nimo para @code{uniteigenvectors}.

@end deffn

@deffn {Fun@value{cedilha}@~{a}o} unitvector (@mvar{x})
@deffnx {Fun@value{cedilha}@~{a}o} uvect (@mvar{x})
Retorna @math{@mvar{x}/norm(@mvar{x})};
isso @'{e} um vetor unit@'{a}rio na mesma dire@value{cedilha}@~{a}o que @mvar{x}.

@code{load ("eigen")} chama essa fun@value{cedilha}@~{a}o.

@code{uvect} @'{e} um sin@^{o}nimo para @code{unitvector}.

@end deffn

@c NEEDS A LOT OF WORK: MAKE SURE THAT ALL VECTOR SIMPLIFICATION FLAGS HAVE A DESCRIPTION HERE
@deffn {Fun@value{cedilha}@~{a}o} vectorsimp (@mvar{expr})
Aplica simplifica@value{cedilha}@~{o}es e expans@~{o}es conforme
os seguintes sinalizadores globais:

@code{expandall}, @code{expanddot}, @code{expanddotplus}, @code{expandcross}, @code{expandcrossplus},
@code{expandcrosscross}, @code{expandgrad}, @code{expandgradplus}, @code{expandgradprod},
@code{expanddiv}, @code{expanddivplus}, @code{expanddivprod}, @code{expandcurl}, @code{expandcurlplus},
@code{expandcurlcurl}, @code{expandlaplacian}, @code{expandlaplacianplus},
e @code{expandlaplacianprod}.

Todos esses sinalizadores possuem valor padr@~{a}o @code{false}.  O sufixo @code{plus} refere-se a
utiliza@value{cedilha}@~{a}o aditivamente ou distribuitivamente.  O sufixo @code{prod} refere-se a
expans@~{a}o para um operando que @'{e} qualquer tipo de produto.

@table @code
@item expandcrosscross
Simplifica @math{p ~ (q ~ r)} para @math{(p . r)*q - (p . q)*r}.
@item expandcurlcurl
Simplifica @math{curl curl p} para @math{grad div p + div grad p}.
@item expandlaplaciantodivgrad
Simplifica @math{laplacian p} para @math{div grad p}.
@item expandcross
Habilita @code{expandcrossplus} e @code{expandcrosscross}.
@item expandplus
Habilita @code{expanddotplus}, @code{expandcrossplus}, @code{expandgradplus},
@code{expanddivplus}, @code{expandcurlplus}, e @code{expandlaplacianplus}.
@item expandprod
Habilita @code{expandgradprod}, @code{expanddivprod}, e @code{expandlaplacianprod}.
@end table

@c EXPLAIN THE IMPORT OF THIS STATEMENT
Esses sinalizadores foram todos declarados @code{evflag}.

@c SEEMS SOME TEXT HAS GONE MISSING HERE; COMMENT OUT FRAGMENT PENDING
@c RECOVERY AND/OR RECONSTRUCTION OF THIS PARAGRAPH
@c For orthogonal curvilinear coordinates, the global variables
@c COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] s@~{a}o set
@c by the function invocation

@end deffn

@defvr {Vari@'{a}vel de op@value{cedilha}@~{a}o} vect_cross
Valor padr@~{a}o: @code{false}

@c WHAT DOES THIS MEAN EXACTLY ??
Quando @code{vect_cross} @'{e} @code{true}, isso permite DIFF(X~Y,T) trabalhar onde
~ @'{e} definido em SHARE;VECT (onde VECT_CROSS @'{e} escolhido para @code{true}, de qualqeur modo.)

@end defvr

@deffn {Fun@value{cedilha}@~{a}o} zeromatrix (@mvar{m}, @mvar{n})
Retorna um matriz @mvar{m} por @mvar{n}, com todos os elementos sendo zero.

@end deffn

@defvr {S@'{i}mbolo especial} [
@defvrx {S@'{i}mbolo especial} ]
@ifinfo
@fnindex Delimitador de Lista
@fnindex Operador de Subscrito
@end ifinfo
@code{[} e @code{]} marcam o ome@value{cedilha}o e o fim, respectivamente, de uma lista.

@code{[} e @code{]} tamb@'{e}m envolvem os subscritos de
uma lista, array, array desordenado, ou fun@value{cedilha}@~{a}o array.

Exemplos:

@example
(%i1) x: [a, b, c];
(%o1)                       [a, b, c]
(%i2) x[3];
(%o2)                           c
(%i3) array (y, fixnum, 3);
(%o3)                           y
(%i4) y[2]: %pi;
(%o4)                          %pi
(%i5) y[2];
(%o5)                          %pi
(%i6) z['foo]: 'bar;
(%o6)                          bar
(%i7) z['foo];
(%o7)                          bar
(%i8) g[k] := 1/(k^2+1);
                                  1
(%o8)                     g  := ------
                           k     2
                                k  + 1
(%i9) g[10];
                                1
(%o9)                          ---
                               101
@end example

@end defvr
