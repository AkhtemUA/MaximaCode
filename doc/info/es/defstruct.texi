@c English version 2011-06-12
@page
@node Estructuras, , Arrays, Tipos de datos y estructuras
@section Estructuras



@menu
* Introducci@'on a las estructuras::       
* Funciones y variables para las estructuras::       
@end menu

@node Introducci@'on a las estructuras, Funciones y variables para las estructuras, Estructuras, Estructuras
@subsection Introducci@'on a las estructuras

Maxima dispone de estructuras para la agregaci@'on de datos.
Una estructura es una expresi@'on en la que los argumentos se definen con
un nombre (nombre del campo) y la estructura en su conjunto se define por
medio de su operador (nombre de la estructura). Los valores dados a los 
campos pueden ser expresiones cualesquiera.

Una estructura se define con la funci@'on @code{defstruct}, guardando la
variable @code{structures} la lista de todas las estructuras definidas
por el usuario. El operador @code{@@} permite hacer referencias a los
campos de la estructura. Con @code{kill(@mvar{S})} se borra la estructura
@mvar{S} completa y @code{kill(@mvar{x}@@ @mvar{a})} elimina la asignaci@'on
actual del campo @mvar{a} en la estructura @mvar{x}.

En la impresi@'on por consola (con @code{display2d} igual a @code{true}),
las estructuras se representan con las asignaciones de los campos en forma de ecuaci@'on,
con el nombre del campo a la izquierda y su valor asociado a la derecha. En la
impresi@'on unidimensional (mediante @code{grind} o d@'andole a @code{display2d}
el valor @code{false}), las estructuras se escriben sin los nombres de los campos.

No es posible utilizar el nombre de un campo como nombre de funci@'on, pero el
valor de un campo s@'{@dotless{i}} puede ser una expresi@'on lambda.
Tampoco es posible restringir los valores de los campos a tipos de datos
concretos, siendo el caso que a cada campo se le puede asignar cualquier
tipo de expresi@'on. Por @'ultimo, no es posible hacer que ciertos campos
sean o no accesibles desde determinados contextos, ya que todos los campos
son siempre visibles.




@node Funciones y variables para las estructuras,  , Introducci@'on a las estructuras, Estructuras
@subsection Funciones y variables para las estructuras

@defvr {Variable global} structures

@code{structures} es la lista que contiene las estructuras definidas por el usuario con @code{defstruct}.

@end defvr



@deffn {Funci@'on} defstruct (@mvar{S}(@mvar{a_1}, ..., @mvar{a_n}))
@deffnx {Funci@'on} defstruct (@mvar{S}(@mvar{a_1} = @mvar{v_1}, ..., @mvar{a_n} = @mvar{v_n}))

Define una estructura, la cual es una lista de nombres de campos @mvar{a_1}, ..., @mvar{a_n}
asociados a un s@'{@dotless{i}}mbolo @mvar{S}.
Todo individuo de una estructura dada consiste en una expresi@'on con operador @mvar{S}
y exactamente @code{n} argumentos. La sentencia @code{new(@mvar{S})} crea un nuevo
individuo con estructura @mvar{S}.

Un argumento consistente en un s@'{@dotless{i}}mbolo @mvar{a} especifica el nombre de
un campo. Un argumento consistente en una ecuaci@'on @code{@mvar{a} = @mvar{v}} especifica
el nombre del campo @mvar{a} junto con su valor por defecto @mvar{v}. El valor por
defecto puede ser cualquier tipo de expresi@'on.

La llamada a @code{defstruct} a@~nade @mvar{S} a la lista de estructuras definidas
por el usuario, @code{structures}.

La sentencia @code{kill(@mvar{S})} borra @mvar{S} de la lista de estructuras
definidas por el usuario y elimina la definici@'on de la estructura.

Ejemplos:

@c ===beg===
@c defstruct (foo (a, b, c));
@c structures;
@c new (foo);
@c defstruct (bar (v, w, x = 123, y = %pi));
@c structures;
@c new (bar);
@c kill (foo);
@c structures;
@c ===end===
@example
(%i1) defstruct (foo (a, b, c));
(%o1)                    [foo(a, b, c)]
(%i2) structures;
(%o2)                    [foo(a, b, c)]
(%i3) new (foo);
(%o3)                     foo(a, b, c)
(%i4) defstruct (bar (v, w, x = 123, y = %pi));
(%o4)             [bar(v, w, x = 123, y = %pi)]
(%i5) structures;
(%o5)      [foo(a, b, c), bar(v, w, x = 123, y = %pi)]
(%i6) new (bar);
(%o6)              bar(v, w, x = 123, y = %pi)
(%i7) kill (foo);
(%o7)                         done
(%i8) structures;
(%o8)             [bar(v, w, x = 123, y = %pi)]
@end example

@end deffn

@deffn {Funci@'on} new (@mvar{S})
@deffnx {Funci@'on} new (@mvar{S} (@mvar{v_1}, ..., @mvar{v_n}))

@code{new} crea nuevos individuos de estructuras declaradas.

La sentencia @code{new(@mvar{S})} crea un nuevo individuo de 
estructura @mvar{S} en el que cada campo toma su valor por defecto,
si este fue definido, o sin valor alguno en caso de que no se haya
fijado un valor por defecto en la definici@'on de la estructura.

La sentencia @code{new(@mvar{S}(@mvar{v_1}, ..., @mvar{v_n}))}
crea un nuevo individuo de estructura @mvar{S} en el que los campos
adquieren los valores @mvar{v_1}, ..., @mvar{v_n}.

Ejemplos:

@c ===beg===
@c defstruct (foo (w, x = %e, y = 42, z));
@c new (foo);
@c new (foo (1, 2, 4, 8));
@c ===end===
@example
(%i1) defstruct (foo (w, x = %e, y = 42, z));
(%o1)              [foo(w, x = %e, y = 42, z)]
(%i2) new (foo);
(%o2)               foo(w, x = %e, y = 42, z)
(%i3) new (foo (1, 2, 4, 8));
(%o3)            foo(w = 1, x = 2, y = 4, z = 8)
@end example

@end deffn

@deffn {Operador} @@

@code{@@} es el operador para acceder a los campos de las estructuras.

La expresi@'on @code{@mvar{x}@@ @mvar{a}} hace referencia al valor del
campo @mvar{a} del individuo @mvar{x} de una estructura dada. El nombre del campo no se eval@'ua.

Si el campo @mvar{a} de @mvar{x} no tiene valor asignado, @code{@mvar{x}@@ @mvar{a}}
se eval@'ua a s@'{@dotless{i}} mismo; es decir, devuelve la propia expresi@'on
@code{@mvar{x}@@ @mvar{a}} tal cual.

La sentencia @code{kill(@mvar{x}@@ @mvar{a})} elimina el valor del campo @mvar{a} de @mvar{x}.

Ejemplos:

@c ===beg===
@c defstruct (foo (x, y, z));
@c u : new (foo (123, a - b, %pi));
@c u@z;
@c u@z : %e;
@c u;
@c kill (u@z);
@c u;
@c u@z;
@c ===end===
@example
(%i1) defstruct (foo (x, y, z));
(%o1)                    [foo(x, y, z)]
(%i2) u : new (foo (123, a - b, %pi));
(%o2)           foo(x = 123, y = a - b, z = %pi)
(%i3) u@@z;
(%o3)                          %pi
(%i4) u@@z : %e;
(%o4)                          %e
(%i5) u;
(%o5)            foo(x = 123, y = a - b, z = %e)
(%i6) kill (u@@z);
(%o6)                         done
(%i7) u;
(%o7)              foo(x = 123, y = a - b, z)
(%i8) u@@z;
(%o8)                          u@@z
@end example

El nombre del campo no se eval@'ua.

@c ===beg===
@c defstruct (bar (g, h));
@c x : new (bar);
@c x@h : 42;
@c h : 123;
@c x@h;
@c x@h : 19;
@c x;
@c h;
@c ===end===
@example
(%i1) defstruct (bar (g, h));
(%o1)                      [bar(g, h)]
(%i2) x : new (bar);
(%o2)                       bar(g, h)
(%i3) x@@h : 42;
(%o3)                          42
(%i4) h : 123;
(%o4)                          123
(%i5) x@@h;
(%o5)                          42
(%i6) x@@h : 19;
(%o6)                          19
(%i7) x;
(%o7)                    bar(g, h = 19)
(%i8) h;
(%o8)                          123
@end example

@end deffn
