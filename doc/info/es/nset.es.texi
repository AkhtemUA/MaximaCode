@c english version 2011-07-8
@menu
* Introducci@'on a los conjuntos::       
* Funciones y variables para los conjuntos::       
@end menu

@node Introducci@'on a los conjuntos, Funciones y variables para los conjuntos, Conjuntos, Conjuntos
@section Introducci@'on a los conjuntos

Maxima dispone de funciones para realizar operaciones con conjuntos, como la intersecci@'on o la uni@'on. Los conjuntos deben ser finitos y definidos por enumeraci@'on. Maxima trata a los conjuntos y a las listas como objectos de distinta naturaleza, lo que permite trabajar con conjuntos cuyos elementos puedan ser tambi@'en conjuntos o listas.

Adem@'as de funciones para operar con conjuntos finitos, Maxima dispone tambi@'en de algunas funciones sobre combinatoria, como los n@'umeros de Stirling de primera y segunda especie, n@'umeros de Bell, coeficientes multinomiales, particiones de enteros no negativos y algunos otros. Maxima tambi@'en define la funci@'on delta de Kronecker.


@subsection Utilizaci@'on

Para construir un conjunto cuyos elementos sean @code{a_1, ..., a_n}, se utiliza la instrucci@'on  @code{set(a_1, ..., a_n)} o @code{@{a_1, ..., a_n@}}; para formar un conjunto vac@'{@dotless{i}}o, basta con hacer @code{set()} o @code{@{@}}. Para introducir conjuntos en Maxima, @code{set (...)} y @code{@{ ... @}} son equivalentes. Los conjuntos se muestran siempre con llave.

Si un elemento se indica m@'as de una vez, el proceso 
de simplificaci@'on elimina los elementos redundantes.

@c ===beg===
@c set();
@c set(a, b, a);
@c set(a, set(b));
@c set(a, [b]);
@c {};
@c {a, b, a};
@c {a, {b}};
@c {a, [b]};
@c ===end===
@example
(%i1) set();
(%o1)                          @{@}
(%i2) set(a, b, a);
(%o2)                        @{a, b@}
(%i3) set(a, set(b));
(%o3)                       @{a, @{b@}@}
(%i4) set(a, [b]);
(%o4)                       @{a, [b]@}
(%i5) @{@};
(%o5)                          @{@}
(%i6) @{a, b, a@};
(%o6)                        @{a, b@}
(%i7) @{a, @{b@}@};
(%o7)                       @{a, @{b@}@}
(%i8) @{a, [b]@};
(%o8)                       @{a, [b]@}
@end example


Dos elementos candidatos a formar parte de un conjunto, @mvar{x} e @mvar{y},
son redundantes, esto es, se consideran el mismo elemento a 
efectos de consruir el conjunto, si y s@'olo si @code{is (@mvar{x} = @mvar{y})}
devuelve el valor @code{true}. N@'otese que @code{is (equal (@mvar{x}, @mvar{y}))}
puede devolver @code{true} y @code{is (@mvar{x} = @mvar{y})} retornar
@code{false}; en cuyo caso los elementos @mvar{x} e @mvar{y} se
considerar@'{@dotless{i}}an distintos.

@c ===beg===
@c x: a/c + b/c;
@c y: a/c + b/c;
@c z: (a + b)/c;
@c is (x = y);
@c is (y = z);
@c is (equal (y, z));
@c y - z;
@c ratsimp (%);
@c {x, y, z};
@c ===end===
@example
(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) @{x, y, z@};
                          b + a  b   a
(%o9)                    @{-----, - + -@}
                            c    c   c
@end example


Para formar un conjunto a partir de los miembros de una lista @'usese @code{setify}.

@c ===beg===
@c setify([b, a]);
@c ===end===
@example
(%i1) setify([b, a]);
(%o1)                        @{a, b@}
@end example

Los elementos @code{x} e @code{y} de un conjunto se consideran iguales si @code{is(x = y)} devuelve el valor @code{true}. As@'{@dotless{i}}, @code{rat(x)} y @code{x} se consideran el mismo elemento de un conjunto; consecuentemente, 

@c ===beg===
@c {x, rat(x)};
@c ===end===
@example
(%i1) @{x, rat(x)@};
(%o1)                          @{x@}
@end example

Adem@'as, puesto que  @code{is((x-1)*(x+1) = x^2 - 1)} devuelve @code{false},  @code{(x-1)*(x+1)} y @code{x^2-1} se consideran elementos diferentes; as@'{@dotless{i}}

@c ===beg===
@c {(x - 1)*(x + 1), x^2 - 1};
@c ===end===
@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
@end example

Para reducir este conjunto a otro unitario, aplicar @code{rat} a cada elemento del conjunto:

@c ===beg===
@c {(x - 1)*(x + 1), x^2 - 1};
@c map (rat, %);
@c ===end===
@example
(%i1) @{(x - 1)*(x + 1), x^2 - 1@};
                                       2
(%o1)               @{(x - 1) (x + 1), x  - 1@}
(%i2) map (rat, %);
                              2
(%o2)/R/                    @{x  - 1@}
@end example

Para eliminar redundancias con otros conjuntos, ser@'a necesario utilizar otras funciones de simplificaci@'on. He aqu@'{@dotless{i}} un ejemplo que utiliza  @code{trigsimp}:

@c ===beg===
@c {1, cos(x)^2 + sin(x)^2};
@c map (trigsimp, %);
@c ===end===
@example
(%i1) @{1, cos(x)^2 + sin(x)^2@};
                            2         2
(%o1)                @{1, sin (x) + cos (x)@}
(%i2) map (trigsimp, %);
(%o2)                          @{1@}
@end example

Se entiende que un conjunto est@'a simplificado cuando entre sus elementos no hay redundancias y se hayan ordenados. La versi@'on actual de las funciones para conjuntos utiliza la funci@'on @code{orderlessp} de Maxima para ordenar sus elementos; sin embargo, @i{futuras versiones de las funciones para operar con conjuntos podr@'an utilizar otras funciones de ordenaci@'on}.

Algunas operaciones con conjuntos, tales como la sustituci@'on, fuerzan autom@'aticamente una re-simplificaci@'on; por ejemplo,

@c ===beg===
@c s: {a, b, c}$
@c subst (c=a, s);
@c subst ([a=x, b=x, c=x], s);
@c map (lambda ([x], x^2), set (-1, 0, 1));
@c ===end===
@example
(%i1) s: @{a, b, c@}$
(%i2) subst (c=a, s);
(%o2)                        @{a, b@}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          @{x@}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        @{0, 1@}
@end example

Maxima considera a las listas y conjuntos como objetos diferentes;
funciones tales como @code{union} y @code{intersection} emitir@'an
un error si alguno de sus argumentos no es un conjunto. Si se 
necesita aplicar una funci@'on de conjunto a una lista, se deber@'a 
utilizar la funci@'on @code{setify} para convertirla previamente en conjunto. 
As@'{@dotless{i}},

@c ===beg===
@c union ([1, 2], {a, b});
@c union (setify ([1, 2]), {a, b});
@c ===end===
@example
(%i1) union ([1, 2], @{a, b@});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), @{a, b@});
(%o2)                     @{1, 2, a, b@}
@end example

Para extraer todos los elementos de un conjunto @code{s} que satisfagan un predicado @code{f}, @'usese @code{subset(s,f)}. (Un @i{predicado} es una funci@'on booleana.) Por ejemplo, para encontrar las ecuaciones en un conjunto dado que no dependan de la variable @code{z}, se har@'a

@c ===beg===
@c subset ({x + y + z, x - y + 4, x + y - 5}, 
@c         lambda ([e], freeof (z, e)));
@c ===end===
@example
(%i1) subset (@{x + y + z, x - y + 4, x + y - 5@},
              lambda ([e], freeof (z, e)));
(%o1)               @{- y + x + 4, y + x - 5@}
@end example

La secci@'on @code{Funciones y variables para los conjuntos} incluye una lista completa de funciones para operar con conjuntos en  Maxima.

@subsection Iteraciones con elementos

Hay dos formas para operar iterativamente sobre los elementos de un conjunto. Una es utilizar @code{map}; por ejemplo:

@c ===beg===
@c map (f, {a, b, c});
@c ===end===
@example
(%i1) map (f, @{a, b, c@});
(%o1)                  @{f(a), f(b), f(c)@}
@end example

La otra forma consiste en hacer uso de la construcci@'on @code{for @mvar{x} in @mvar{s} do}

@c ===beg===
@c s: {a, b, c};
@c for si in s do print (concat (si, 1));
@c ===end===
@example
(%i1) s: @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
@end example

Las funciones de Maxima  @code{first} y @code{rest} funcionan tambi@'en con conjuntos.  En este caso, @code{first} devuelve el primer elemento que se muestra del conjunto, el cual puede depender de la implementaci@'on del sistema. Si @code{s} es un conjunto, entonces @code{rest(s)} equivale a @code{disjoin (first(s), s)}. Hay otras funciones que trabajan correctamente con conjuntos. En pr@'oximas versiones de las funciones para operar con conjuntos es posible que @code{first} y @code{rest} trabajen de modo diferente o que ya no lo hagan en absoluto.

@subsection Fallos

Las funciones para operar con conjuntos utilizan la funci@'on @code{orderlessp}
de Maxima para ordenar los elementos de los conjuntos, as@'{@dotless{i}}
como la funci@'on @code{like} de Lisp para decidir sobre la igualdad de dichos
elementos. Ambas funciones tienen fallos que son conocidos y que pueden
aflorar si se trabaja con conjuntos que tengan elementos en formato de
listas o matrices y que contengan expresiones racionales can@'onicas (CRE).
Un ejemplo es

@c ===beg===
@c {[x], [rat (x)]};
@c ===end===
@example
(%i1) @{[x], [rat (x)]@};
Maxima encountered a Lisp error:

  The value #:X1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Esta expresi@'on provoca una parada de Maxima junto con la 
emisi@'on de un mensaje de error, el cual depender@'a de 
la versi@'on de Lisp que utilice Maxima. Otro ejemplo es

@c ===beg===
@c setify ([[rat(a)], [rat(b)]]);
@c ===end===
@example
(%i1) setify ([[rat(a)], [rat(b)]]);
Maxima encountered a Lisp error:

  The value #:A1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
@end example

Estos fallos son causados por fallos en  @code{orderlessp} y @code{like},
no por fallos cuyo origen se encuentre en las funciones para conjuntos.
Para ilustrarlo, se pueden ejecutar las siguientes expresiones

@c ===beg===
@c orderlessp ([rat(a)], [rat(b)]);
@c is ([rat(a)] = [rat(a)]);
@c ===end===
@example
(%i1) orderlessp ([rat(a)], [rat(b)]);
Maxima encountered a Lisp error:

  The value #:B1441 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i2) is ([rat(a)] = [rat(a)]);
(%o2)                         false
@end example

Hasta que estos errores no se corrijan, no es aconsejable construir conjuntos que tengan por elementos listas o matrices que contengan expresiones en forma CRE; sin embargo, un conjunto con elementos de la forma CRE no deber@'{@dotless{i}}an dar problemas:

@c ===beg===
@c {x, rat (x)};
@c ===end===
@example
(%i1) @{x, rat (x)@};
(%o1)                          @{x@}
@end example

La funci@'on @code{orderlessp} de Maxima tiene otro fallo que puede causar problemas con las funciones para conjuntos, en concreto, que el predicado de ordenaci@'on @code{orderlessp} no es transitivo. El ejemplo m@'as simple que ilustra este punto es

@c ===beg===
@c q: x^2$
@c r: (x + 1)^2$
@c s: x*(x + 2)$
@c orderlessp (q, r);
@c orderlessp (r, s);
@c orderlessp (q, s);
@c ===end===
@example
(%i1) q: x^2$
(%i2) r: (x + 1)^2$
(%i3) s: x*(x + 2)$
(%i4) orderlessp (q, r);
(%o4)                         true
(%i5) orderlessp (r, s);
(%o5)                         true
(%i6) orderlessp (q, s);
(%o6)                         false
@end example

El fallo puede causar problemas con todas las funciones para conjuntos,
as@'{@dotless{i}} como tambi@'en con otras funciones de Maxima.
Es probable, pero no seguro, que este fallo se puede evitar si todos 
los elementos del conjunto est@'an en la forma de expresi@'on racional
can@'onica (CRE) o han sido simplificados con @code{ratsimp}.

@c WHAT EXACTLY IS THE EFFECT OF ordergreat AND orderless ON THE SET FUNCTIONS ??
Los mecanismos @code{orderless} y @code{ordergreat} de Maxima son incompatibles
con las funciones para conjuntos. Si se necesitan utilizar @code{orderless} o
@code{ordergreat}, h@'agase antes de construir los conjuntos y no se utilice 
la instrucci@'on @code{unorder}.

Se ruega a todo usuario que crea haber encontrado un fallo en las funciones para conjuntos que lo comunique en la base de datos de Maxima. V@'ease @code{bug_report}.

@subsection Autores

Stavros Macrakis de Cambridge, Massachusetts y Barton Willis de la University of Nebraska at Kearney (UNK).

@node Funciones y variables para los conjuntos,  , Introducci@'on a los conjuntos, Conjuntos
@section Funciones y variables para los conjuntos


@deffn {Funci@'on} adjoin (@mvar{x}, @mvar{a}) 

Calcula la uni@'on del conjunto @mvar{a} y @code{@{@mvar{x}@}}.

La funci@'on @code{adjoin} emite un mensaje de error si @mvar{a}
no es un conjunto literal.

Las sentencias @code{adjoin(@mvar{x}, @mvar{a})} y 
@code{union(set(@mvar{x}), @mvar{a})} son equivalentes, aunque
@code{adjoin} puede ser algo m@'as r@'apida que @code{union}.

V@'ease tambi@'en @code{disjoin}.

Ejemplos:

@c ===beg===
@c adjoin (c, {a, b});
@c adjoin (a, {a, b});
@c ===end===
@example
(%i1) adjoin (c, @{a, b@});
(%o1)                       @{a, b, c@}
(%i2) adjoin (a, @{a, b@});
(%o2)                        @{a, b@}
@end example

@end deffn


@deffn {Funci@'on} belln (@mvar{n})

Representa el @math{n}-@'esimo n@'umero de Bell, de
modo que @code{belln(n)} es el n@'umero de particiones de un conjunto de 
@mvar{n} elementos.

El argumento @mvar{n} debe ser un entero no negativo.

La funci@'on @code{belln} se distribuye sobre ecuaciones, listas,
matrices y conjuntos.

Ejemplos:

@code{belln} se aplica a enteros no negativos,

@c ===beg===
@c makelist (belln (i), i, 0, 6);
@c is (cardinality (set_partitions ({})) = belln (0));
@c is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6}))
@c                          = belln (6));
@c ===end===
@example
(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions (@{@})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions (@{1, 2, 3, 4, 5, 6@}))
                            = belln (6));
(%o3)                         true
@end example

Si @mvar{n} no es un entero no negativo, la funci@'on @code{belln(n)} no hace c@'alculo alguno.

@c ===beg===
@c [belln (x), belln (sqrt(3)), belln (-9)];
@c ===end===
@example
(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
@end example
@end deffn


@deffn {Funci@'on} cardinality (@mvar{a})

Devuelve el n@'umero de elementos del conjunto @mvar{a}.

La funci@'on @code{cardinality} ignora los elementos
redundantes, incluso cuando la simplificaci@'on est@'a
desabilitada.

Ejemplos:

@c ===beg===
@c cardinality ({});
@c cardinality ({a, a, b, c});
@c simp : false;
@c cardinality ({a, a, b, c});
@c ===end===
@example
(%i1) cardinality (@{@});
(%o1)                           0
(%i2) cardinality (@{a, a, b, c@});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality (@{a, a, b, c@});
(%o4)                           3
@end example
@end deffn


@deffn {Funci@'on} cartesian_product (@mvar{b_1}, ... , @mvar{b_n})

Devuelve un conjunto formado por listas de la forma @code{[@mvar{x_1}, ..., @mvar{x_n}]},
siendo @mvar{x_1}, ..., @mvar{x_n} elementos de los conjuntos @mvar{b_1}, ... , @mvar{b_n},
respectivamente.

La funci@'on @code{cartesian_product} emite un mensaje de error si alguno
de sus argumentos no es un conjunto literal.

Ejemplos:

@c ===beg===
@c cartesian_product ({0, 1});
@c cartesian_product ({0, 1}, {0, 1});
@c cartesian_product ({x}, {y}, {z});
@c cartesian_product ({x}, {-1, 0, 1});
@c ===end===
@example
(%i1) cartesian_product (@{0, 1@});
(%o1)                      @{[0], [1]@}
(%i2) cartesian_product (@{0, 1@}, @{0, 1@});
(%o2)           @{[0, 0], [0, 1], [1, 0], [1, 1]@}
(%i3) cartesian_product (@{x@}, @{y@}, @{z@});
(%o3)                      @{[x, y, z]@}
(%i4) cartesian_product (@{x@}, @{-1, 0, 1@});
(%o4)              @{[x, - 1], [x, 0], [x, 1]@}
@end example
@end deffn


@deffn {Funci@'on} disjoin (@mvar{x}, @mvar{a})

Devuelve el conjunto @mvar{a} sin el elemento @mvar{x}.
Si @mvar{x} no es elemento de @mvar{a}, entonces el
resultado es el propio @mvar{a}.

La funci@'on @code{disjoin} emite un mensaje de error si
@mvar{a} no es un conjunto literal.

Las sentencias @code{disjoin(@mvar{x}, @mvar{a})}, @code{delete(@mvar{x}, @mvar{a})}
y @code{setdifference(@mvar{a}, set(@mvar{x}))} son todas ellas equivalentes;
pero en general, @code{disjoin} ser@'a m@'as r@'apida que las otras.

Ejemplos:

@c ===beg===
@c disjoin (a, {a, b, c, d});
@c disjoin (a + b, {5, z, a + b, %pi});
@c disjoin (a - b, {5, z, a + b, %pi});
@c ===end===
@example
(%i1) disjoin (a, @{a, b, c, d@});
(%o1)                       @{b, c, d@}
(%i2) disjoin (a + b, @{5, z, a + b, %pi@});
(%o2)                      @{5, %pi, z@}
(%i3) disjoin (a - b, @{5, z, a + b, %pi@});
(%o3)                  @{5, %pi, b + a, z@}
@end example
@end deffn


@deffn {Funci@'on} disjointp (@mvar{a}, @mvar{b}) 

Devuelve @code{true} si y s@'olo si los conjuntos  @mvar{a} y @mvar{b}
son disjuntos.

La funci@'on @code{disjointp} emite un mensaje de error si
@mvar{a} o @mvar{b} no son conjuntos literales.

Ejemplos:

@c ===beg===
@c disjointp ({a, b, c}, {1, 2, 3});
@c disjointp ({a, b, 3}, {1, 2, 3});
@c ===end===
@example
(%i1) disjointp (@{a, b, c@}, @{1, 2, 3@});
(%o1)                         true
(%i2) disjointp (@{a, b, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example
@end deffn


@deffn {Funci@'on} divisors (@mvar{n})

Calcula el conjunto de divisores de @mvar{n}.

La sentencia @code{divisors(@mvar{n})} devuelve un conjunto
de enteros si @mvar{n} es un entero no nulo.
El conjunto de divisores incluye los elementos 1 y @mvar{n}.
Los divisores de un entero negativo son los divisores de su
valor absoluto.

La funci@'on @code{divisors} se distribuye sobre las ecuaciones,
listas, matrices y conjuntos.

Ejemplos:

Se puede comprobar que 28 es un n@'umero perfecto:
la suma de sus divisores (excepto @'el mismo) es 28.

@c ===beg===
@c s: divisors(28);
@c lreduce ("+", args(s)) - 28;
@c ===end===
@example
(%i1) s: divisors(28);
(%o1)                 @{1, 2, 4, 7, 14, 28@}
(%i2) lreduce ("+", args(s)) - 28;
(%o2)                          28
@end example

La funci@'on @code{divisors} es simplificadora.
Haciendo la sustituci@'on de @code{a} por 8 en @code{divisors(a)}
devuelve los divisores sin tener que reevaluar @code{divisors(8)},

@c ===beg===
@c divisors (a);
@c subst (8, a, %);
@c ===end===
@example
(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     @{1, 2, 4, 8@}
@end example

La funci@'on @code{divisors} se distribuye sobre ecuaciones, listas,
matrices y conjuntos.

@c ===beg===
@c divisors (a = b);
@c divisors ([a, b, c]);
@c divisors (matrix ([a, b], [c, d]));
@c divisors ({a, b, c});
@c ===end===
@example
(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors (@{a, b, c@});
(%o4)        @{divisors(a), divisors(b), divisors(c)@}
@end example
@end deffn


@deffn {Funci@'on} elementp (@mvar{x}, @mvar{a})

Devuelve @code{true} si y s@'olo si @mvar{x} es miembro del
conjunto @mvar{a}.

La funci@'on @code{elementp} emite un mensaje de error si 
@mvar{a} no es un conjunto literal.

Ejemplos: 

@c ===beg===
@c elementp (sin(1), {sin(1), sin(2), sin(3)});
@c elementp (sin(1), {cos(1), cos(2), cos(3)});
@c ===end===
@example
(%i1) elementp (sin(1), @{sin(1), sin(2), sin(3)@});
(%o1)                         true
(%i2) elementp (sin(1), @{cos(1), cos(2), cos(3)@});
(%o2)                         false
@end example
@end deffn


@deffn {Funci@'on} emptyp (@mvar{a})
Devuelve @code{true} si y s@'olo si @mvar{a} es el conjunto vac@'{@dotless{i}}o o la lista vac@'{@dotless{i}}a.

Ejemplos:

@c ===beg===
@c map (emptyp, [{}, []]);
@c map (emptyp, [a + b, {{}}, %pi]);
@c ===end===
@example
(%i1) map (emptyp, [@{@}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, @{@{@}@}, %pi]);
(%o2)                 [false, false, false]
@end example
@end deffn
       

@deffn {Funci@'on} equiv_classes (@mvar{s}, @mvar{F})

Devuelve el conjunto de las clases de equivalencia del conjunto @mvar{s}
respecto de la relaci@'on de equivalencia @mvar{F}.

El argumento @mvar{F} es una funci@'on de dos variables definida sobre
el producto cartesiano @mvar{s} por @mvar{s}.
El valor devuelto por @mvar{F} debe ser @code{true} o @code{false},
o bien una expresi@'on @mvar{expr} tal que @code{is(@mvar{expr})}
tome el valor @code{true} o @code{false}.

Si @mvar{F} no es una relaci@'on de equivalencia, @code{equiv_classes}
la acepta sin emitir ning@'un mensaje de error, pero el resultado
ser@'a incorrecto en general.

Ejemplos:

La relaci@'on de equivalencia es una expresi@'on lambda que devuelve 
@code{true} o @code{false},

@c ===beg===
@c equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
@c                 lambda ([x, y], is (equal (x, y))));
@c ===end===
@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@},
                      lambda ([x, y], is (equal (x, y))));
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

La relaci@'on de equivalencia es el nombre de una funci@'on relacional
en la que @code{is} eval@'ua a @code{true} o @code{false},

@c ===beg===
@c equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
@c ===end===
@example
(%i1) equiv_classes (@{1, 1.0, 2, 2.0, 3, 3.0@}, equal);
(%o1)            @{@{1, 1.0@}, @{2, 2.0@}, @{3, 3.0@}@}
@end example

Las clases de equivalencia son n@'umeros que difieren en un m@'ultiplo de 3.

@c ===beg===
@c equiv_classes ({1, 2, 3, 4, 5, 6, 7}, 
@c             lambda ([x, y], remainder (x - y, 3) = 0));
@c ===end===
@example
(%i1) equiv_classes (@{1, 2, 3, 4, 5, 6, 7@}, 
              lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              @{@{1, 4, 7@}, @{2, 5@}, @{3, 6@}@}
@end example
@end deffn


@deffn {Funci@'on} every (@mvar{f}, @mvar{s})
@deffnx {Funci@'on} every (@mvar{f}, @mvar{L_1}, ..., @mvar{L_n})

Devuelve @code{true} si el predicado @mvar{f} vale @code{true}
para todos los argumentos dados.

Dado un conjunto como segundo argumento,
@code{every(@mvar{f}, @mvar{s})} devuelve @code{true}
si @code{is(@mvar{f}(@mvar{a_i}))} devuelve @code{true} para todos los
@mvar{a_i} pertenecientes @mvar{s}.
La funci@'on @code{every} puede evaluar o no @mvar{f} para todos los
@mvar{a_i} pertenecientes @mvar{s}.
Puesto que los conjuntos no est@'an ordenados, @code{every}
puede evaluar @code{@mvar{f}(@mvar{a_i})} en cualquier orden.

Dada una o m@'as listas como argumentos,
@code{every(@mvar{f}, @mvar{L_1}, ..., @mvar{L_n})} devuelve @code{true}
si @code{is(@mvar{f}(@mvar{x_1}, ..., @mvar{x_n}))} devuelve @code{true} 
para todo @mvar{x_1}, ..., @mvar{x_n} en @mvar{L_1}, ..., @mvar{L_n}, respectivamente.
La funci@'on @code{every} puede evaluar o no 
@mvar{f} para cualquier combinaci@'on de @mvar{x_1}, ..., @mvar{x_n}; adem@'as,
@code{every} eval@'ua las listas en el orden creciente del @'{@dotless{i}}ndice.

Dado un conjunto vac@'{@dotless{i}}o @code{@{@}} o lista vac@'{@dotless{i}}a 
@code{[]} como argumentos, @code{every} devuelve @code{false}.

Si la variable global @code{maperror} vale @code{true}, todas las listas
@mvar{L_1}, ..., @mvar{L_n} deben ser de igual longitud.
Si @code{maperror} vale @code{false}, los argumentos en forma de listas
se truncan para igualar sus longitudes a la de la lista m@'as corta.

Los valores que devuelve el predicado @mvar{f} cuando toman 
(mediante @code{is}) un valor diferente a @code{true} y @code{false}
se controlan con la variable global @code{prederror}.
Si @code{prederror} vale @code{true}, tales valores se
consideran como @code{false} y la respuesta de @code{every} es @code{false}.
Si @code{prederror} vale @code{false}, tales valores se
consideran como desconocidos (@code{unknown}) y la respuesta de 
@code{every} es @code{unknown}.

Ejemplos:

Se aplica @code{every} a un @'unico conjunto.
El predicado es una funci@'on de un argumento.

@c ===beg===
@c every (integerp, {1, 2, 3, 4, 5, 6});
@c every (atom, {1, 2, sin(3), 4, 5 + y, 6});
@c ===end===
@example
(%i1) every (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) every (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         false
@end example

Se aplica @code{every} a dos listas.
El predicado es una funci@'on de dos argumentos.

@c ===beg===
@c every ("=", [a, b, c], [a, b, c]);
@c every ("#", [a, b, c], [a, b, c]);
@c ===end===
@example
(%i1) every ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

Las respuestas del predicado @mvar{f} que se eval@'uan 
a cualquier cosa diferente de @code{true} y @code{false}
est@'an controlados por la variable global @code{prederror}.

@c ===beg===
@c prederror : false;
@c map (lambda ([a, b], is (a < b)), [x, y, z],
@c                [x^2, y^2, z^2]);
@c every ("<", [x, y, z], [x^2, y^2, z^2]);
@c prederror : true;
@c every ("<", [x, y, z], [x^2, y^2, z^2]);
@c ===end===
@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                   [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every ("<", [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
@end example
@end deffn
 

@deffn {Funci@'on} extremal_subset (@mvar{s}, @mvar{f}, max)
@deffnx {Funci@'on} extremal_subset (@mvar{s}, @mvar{f}, min)

Calcula el subconjunto de @mvar{s} para el cual la funci@'on @mvar{f}
toma sus valores mayor y menor.

La sentencia @code{extremal_subset(@mvar{s}, @mvar{f}, max)}
devuelve el subconjunto del conjunto o lista @mvar{s} para el cual
la funci@'on real @mvar{f} toma su valor m@'aximo.

La sentencia @code{extremal_subset(@mvar{s}, @mvar{f}, min)}
devuelve el subconjunto del conjunto o lista @mvar{s} para el cual
la funci@'on real @mvar{f} toma su valor m@'{@dotless{i}}nimo.

Ejemplos

@c ===beg===
@c extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
@c extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
@c ===end===
@example
(%i1) extremal_subset (@{-2, -1, 0, 1, 2@}, abs, max);
(%o1)                       @{- 2, 2@}
(%i2) extremal_subset (@{sqrt(2), 1.57, %pi/2@}, sin, min);
(%o2)                       @{sqrt(2)@}
@end example
@end deffn


@deffn {Funci@'on} flatten (@mvar{expr})

Recoge los argumentos de subexpresiones con el mismo operador que @mvar{expr}
y construye con ellas otra expresi@'on a partir de estos argumentos.

Aquellas subexpresiones en las que el operador es diferente del operador
principal de @code{expr} se copian sin modificarse, incluso cuando ellas
mismas contengan subexpresiones en las que el operador sea el mismo 
que el de @code{expr}.

Es posible que @code{flatten} construya expresiones en las que el n@'umero
de argumentos difiera del n@'umero admitido por el operador, lo cual
har@'a que se emita un mensaje de error. La funci@'on @code{flatten}
no intentar@'a detectar estas situaciones.

Las expresiones que tengan representaciones especiales, por ejemplo las racionales
can@'onicas (CRE), no admiten que se aplique sobre ellas la funci@'on @code{flatten};
en tales casos se devuelve el argumento sin modificaci@'on.

Ejemplos:

Aplicada a una lista, @code{flatten} reune todos los elementos que son a su vez listas.

@c ===beg===
@c flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
@c ===end===
@example
(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
@end example

Aplicado a un conjunto, @code{flatten} reune todos los elementos que son a su vez conjuntos.

@c ===beg===
@c flatten ({a, {b}, {{c}}});
@c flatten ({a, {[a], {a}}});
@c ===end===
@example
(%i1) flatten (@{a, @{b@}, @{@{c@}@}@});
(%o1)                       @{a, b, c@}
(%i2) flatten (@{a, @{[a], @{a@}@}@});
(%o2)                       @{a, [a]@}
@end example

La funci@'on @code{flatten} es similar a la declaraci@'on del operador
principal como n-ario. Sin embargo, @code{flatten} no tiene efecto alguno
sobre subexpresiones que tengan un operador diferente del principal, mientras
que s@'{@dotless{i}} lo tiene una declaraci@'on n-aria.


@c ===beg===
@c expr: flatten (f (g (f (f (x)))));
@c declare (f, nary);
@c ev (expr);
@c ===end===
@example
(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
@end example

La funci@'on @code{flatten} trata las funciones subindicadas como
a cualquier otro operador.

@c ===beg===
@c flatten (f[5] (f[5] (x, y), z));
@c ===end===
@example
(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
@end example

Es posible que @code{flatten} construya expresiones en las que el n@'umero
de argumentos difiera del n@'umero admitido por el operador.

@c ===beg===
@c 'mod (5, 'mod (7, 4));
@c flatten (%);
@c ''%, nouns;
@c ===end===
@example
(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
@end example
@end deffn


@deffn {Funci@'on} full_listify (@mvar{a})

Sustituye los operadores de conjunto presentes en @mvar{a}
por operadores de listas, devolviendo el resultado.
La funci@'on @code{full_listify} sustituye operadores de 
conjuntos en subexpresiones anidadas, incluso cuando
el operador principal no es @code{set}.

La funci@'on @code{listify} sustituye @'unicamente el
operador principal.

Ejemplos:

@c ===beg===
@c full_listify ({a, b, {c, {d, e, f}, g}});
@c full_listify (F (G ({a, b, H({c, d, e})})));
@c ===end===
@example
(%i1) full_listify (@{a, b, @{c, @{d, e, f@}, g@}@});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G (@{a, b, H(@{c, d, e@})@})));
(%o2)              F(G([a, b, H([c, d, e])]))
@end example
@end deffn


@deffn {Funci@'on} fullsetify (@mvar{a})

Si @mvar{a} es una lista, sustituye el operador de lista por el
de conjunto, aplicando posteriormente @code{fullsetify} a todos
los elementos que son a su vez conjuntos.
Si @mvar{a} no es una lista, se devuelve sin cambio alguno.

La funci@'on @code{setify} sustituye solamente el operador principal.

Ejemplos:

En la salida @code{(%o2)} el argumento de @code{f} no se convierte en
conjunto porque el operador principal de @code{f([b])} no es una lista.

@c ===beg===
@c fullsetify ([a, [a]]);
@c fullsetify ([a, f([b])]);
@c ===end===
@example
(%i1) fullsetify ([a, [a]]);
(%o1)                       @{a, @{a@}@}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      @{a, f([b])@}
@end example
@end deffn


@deffn {Funci@'on} identity (@mvar{x})

La funci@'on @code{identity} devuelve su argumento cualquiera que sea @'este.

Ejemplos:

La funci@'on @code{identity} puede utilizarse como predicado cuando
los argumentos ya son valores booleanos.

@c ===beg===
@c every (identity, [true, true]);
@c ===end===
@example
(%i1) every (identity, [true, true]);
(%o1)                         true
@end example
@end deffn


@deffn {Funci@'on} integer_partitions (@mvar{n})
@deffnx {Funci@'on} integer_partitions (@mvar{n}, @mvar{len})

Devuelve particiones enteras de @mvar{n}, esto es,
listas de enteros cuyas sumas son @mvar{n}.

La sentencia @code{integer_partitions(@mvar{n})}
devuelve el conjunto de todas las particiones del entero @mvar{n}.
Cada partici@'on es una lista ordenada de mayor a menor.

La sentencia @code{integer_partitions(@mvar{n}, @mvar{len})}
devuelve todas las particiones de longitud @mvar{len} o menor;
en este caso, se a@~naden ceros a cada partici@'on con menos
de @mvar{len} t@'erminos para que todas ellas sean de longitud
@mvar{len}. Las particiones son listas ordenadas de mayor a menor.

Una lista @math{[a_1, ..., a_m]} es una partici@'on de un entero no
negativo @math{n} si (1) cada @math{a_i} es entero no nulo y (2)
@math{a_1 + ... + a_m = n.} As@'{@dotless{i}}, 0 no tiene particiones.

Ejemplos:

@c ===beg===
@c integer_partitions (3);
@c s: integer_partitions (25)$
@c cardinality (s);
@c map (lambda ([x], apply ("+", x)), s);
@c integer_partitions (5, 3);
@c integer_partitions (5, 2);
@c ===end===
@example
(%i1) integer_partitions (3);
(%o1)               @{[1, 1, 1], [2, 1], [3]@}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply ("+", x)), s);
(%o4)                         @{25@}
(%i5) integer_partitions (5, 3);
(%o5) @{[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]@}
(%i6) integer_partitions (5, 2);
(%o6)               @{[3, 2], [4, 1], [5, 0]@}
@end example

Para encontrar todas las particiones que satisfagan cierta
condici@'on, util@'{@dotless{i}}cese la funci@'on @code{subset};
he aqu@'{@dotless{i}} un ejemplo que encuentra todas las
particiones de 10 formadas por n@'umeros primos.

@c ===beg===
@c s: integer_partitions (10)$
@c cardinality (s);
@c xprimep(x) := integerp(x) and (x > 1) and primep(x)$
@c subset (s, lambda ([x], every (xprimep, x)));
@c ===end===
@example
(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x > 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) @{[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]@}
@end example
@end deffn


@deffn {Funci@'on} intersect (@mvar{a_1}, ..., @mvar{a_n})
Es una forma abreviada de la funci@'on @code{intersection}.
@end deffn


@deffn {Funci@'on} intersection (@mvar{a_1}, ..., @mvar{a_n})

Devuelve el conjunto de todos los elementos que son
comunes a los conjuntos  @mvar{a_1} a @mvar{a_n}.

Emite un mensaje de error en caso de que cualquiera de los 
@mvar{a_i} no sea un conjunto.

Ejemplos:

@c ===beg===
@c S_1 : {a, b, c, d};
@c S_2 : {d, e, f, g};
@c S_3 : {c, d, e, f};
@c S_4 : {u, v, w};
@c intersection (S_1, S_2);
@c intersection (S_2, S_3);
@c intersection (S_1, S_2, S_3);
@c intersection (S_1, S_2, S_3, S_4);
@c ===end===
@example
(%i1) S_1 : @{a, b, c, d@};
(%o1)                     @{a, b, c, d@}
(%i2) S_2 : @{d, e, f, g@};
(%o2)                     @{d, e, f, g@}
(%i3) S_3 : @{c, d, e, f@};
(%o3)                     @{c, d, e, f@}
(%i4) S_4 : @{u, v, w@};
(%o4)                       @{u, v, w@}
(%i5) intersection (S_1, S_2);
(%o5)                          @{d@}
(%i6) intersection (S_2, S_3);
(%o6)                       @{d, e, f@}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          @{d@}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          @{@}
@end example
@end deffn

@deffn {Funci@'on} kron_delta (@mvar{x1}, @mvar{y1}, @dots{}, @mvar{xp}, @mvar{yp})

Es la funci@'on delta de Kronecker.

La funci@'on @code{kron_delta} devuelve 1 cuando @mvar{xi} y
@mvar{yi} son iguales para todos los pares, devolviendo 0 si existe
un par en el que @mvar{xi} y @mvar{yi} no sean iguales. La igualdad
se determina utilizando @code{is(equal(xi,xj))} y la desigualdad
con @code{is(notequal(xi,xj))}. En caso de un solo argumento,
@code{kron_delta} devuelve un mensaje de error.

Ejemplos:

@c ===beg===
@c kron_delta(a,a);
@c kron_delta(a,b,a,b);
@c kron_delta(a,a,b,a+1);
@c assume(equal(x,y));
@c kron_delta(x,y);
@c ===end===
@example
(%i1) kron_delta(a,a);
(%o1)                                  1
(%i2) kron_delta(a,b,a,b);
(%o2)                          kron_delta(a, b)
(%i3) kron_delta(a,a,b,a+1);
(%o3)                                  0
(%i4) assume(equal(x,y));
(%o4)                            [equal(x, y)]
(%i5) kron_delta(x,y);
(%o5)                                  1
@end example
@end deffn


@deffn {Funci@'on} listify (@mvar{a})

Si @mvar{a} es un conjunto, devuelve una lista con los elementos de @mvar{a};
si  @mvar{a} no es un conjunto, devuelve @mvar{a}.

La funci@'on @code{full_listify} sustituye todos los operadores
de conjunto en @mvar{a} por operadores de lista.

Ejemplos:

@c ===beg===
@c listify ({a, b, c, d});
@c listify (F ({a, b, c, d}));
@c ===end===
@example
(%i1) listify (@{a, b, c, d@});
(%o1)                     [a, b, c, d]
(%i2) listify (F (@{a, b, c, d@}));
(%o2)                    F(@{a, b, c, d@})
@end example
@end deffn


@deffn {Funci@'on} lreduce (@mvar{f}, @mvar{s})
@deffnx {Funci@'on} lreduce (@mvar{f}, @mvar{s}, @mvar{init})

Ampl@'{@dotless{i}}a la funci@'on binaria @mvar{F} a n-aria mediante
composici@'on, siendo @mvar{s} una lista.

La sentencia  @code{lreduce(@mvar{F}, @mvar{s})} devuelve
@code{F(... F(F(s_1, s_2), s_3), ... s_n)}.
Si se incluye el argumento opcional @mvar{s_0},
el resultado equivale a @code{lreduce(@mvar{F}, cons(@mvar{s_0}, @mvar{s}))}.

La funci@'on @mvar{F} se aplica primero a los elementos del
extremo izquierdo de la lista, de ah@'{@dotless{i}} el nombre
@code{lreduce}, (@i{left reduce}).

V@'eanse tambi@'en @code{rreduce}, @code{xreduce} y @code{tree_reduce}.

Ejemplos:

La funci@'on @code{lreduce} sin el argumento opcional,

@c ===beg===
@c lreduce (f, [1, 2, 3]);
@c lreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
@end example

La funci@'on @code{lreduce} con el argumento opcional,

@c ===beg===
@c lreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
@end example

La funci@'on @code{lreduce} aplicada a operadores binarios de Maxima.
El s@'{@dotless{i}}mbolo @code{/} es el operador divisi@'on.

@c ===beg===
@c lreduce ("^", args ({a, b, c, d}));
@c lreduce ("/", args ({a, b, c, d}));
@c ===end===
@example
(%i1) lreduce ("^", args (@{a, b, c, d@}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce ("/", args (@{a, b, c, d@}));
                                a
(%o2)                         -----
                              b c d
@end example

@end deffn


@deffn {Funci@'on} makeset (@mvar{expr}, @mvar{x}, @mvar{s})

Genera un conjunto cuyos miembros se generan a partir de la
expresi@'on @mvar{expr}, siendo @mvar{x} una lista de variables de
@mvar{expr} y @mvar{s} un conjunto o lista de listas.
Para generar los elementos del conjunto, se eval@'ua @mvar{expr}
asignando a las variables de @mvar{x} los elementos de @mvar{s}
en paralelo.

Los elementos de @mvar{s} deben tener la misma longitud que @mvar{x}.
La lista de variables @mvar{x} debe ser una lista de s@'{@dotless{i}}mbolos
sin sub@'{@dotless{i}}ndices. Cuando se trate de un @'unico s@'{@dotless{i}}mbolo,
@mvar{x} debe expresarse como una lista de un elemento y cada elemento de @mvar{s}
debe ser una lista de un s@'olo elemento.

@c FOLLOWING EQUIVALENT EXPRESSION IS REALLY TOO COMPLICATED, JUST SKIP IT FOR NOW
@c @code{makeset(@mvar{expr}, @mvar{x}, @mvar{s})} returns the same result as
@c @code{setify(map(lambda([L], sublis(map("=", ''@mvar{x}, L), ''@mvar{expr})), args(@mvar{s})))}.

V@'ease tambi@'en @code{makelist}.

Ejemplos:

@c ===beg===
@c makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
@c S : {x, y, z}$
@c S3 : cartesian_product (S, S, S);
@c makeset (i + j + k, [i, j, k], S3);
@c makeset (sin(x), [x], {[1], [2], [3]});
@c ===end===
@example
(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     @{-, -, -, -@}
                           a  b  c  d
(%i2) S : @{x, y, z@}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) @{[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y], 
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x], 
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z], 
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y], 
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x], 
[z, z, y], [z, z, z]@}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) @{3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x, 
                                       z + 2 y, 2 z + x, 2 z + y@}
(%i5) makeset (sin(x), [x], @{[1], [2], [3]@});
(%o5)               @{sin(1), sin(2), sin(3)@}
@end example
@end deffn


@deffn {Funci@'on} moebius (@mvar{n})

Representa la funci@'on de Moebius.

Si @mvar{n} es el producto de @math{k} n@'umeros primos diferentes,
@code{moebius(@mvar{n})} devuelve @math{(-1)^k}, retornando 1 si 
@math{@mvar{n} = 1} y 0 para cualesquiera otros enteros positivos.


La funci@'on de Moebius se distribuye respecto de ecuaciones,
listas, matrices y conjuntos.

Ejemplos:

@c ===beg===
@c moebius (1);
@c moebius (2 * 3 * 5);
@c moebius (11 * 17 * 29 * 31);
@c moebius (2^32);
@c moebius (n);
@c moebius (n = 12);
@c moebius ([11, 11 * 13, 11 * 13 * 15]);
@c moebius (matrix ([11, 12], [13, 14]));
@c moebius ({21, 22, 23, 24});
@c ===end===
@example
(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius (@{21, 22, 23, 24@});
(%o9)                      @{- 1, 0, 1@}
@end example
@end deffn
 

@deffn {Funci@'on} multinomial_coeff (@mvar{a_1}, ..., @mvar{a_n})
@deffnx {Funci@'on} multinomial_coeff ()

Calcula el coeficiente multinomial.

Si todos los @mvar{a_k} son enteros no negativos, el coeficiente multinomial
es el n@'umero de formas de colocar  @code{@mvar{a_1} + ... + @mvar{a_n}}
objetos diferentes en  @math{n} cajas con @mvar{a_k} elementos en la
@math{k}-@'esima caja. En general,
@code{multinomial_coeff (@mvar{a_1}, ..., @mvar{a_n})} calcula
@code{(@mvar{a_1} + ... + @mvar{a_n})!/(@mvar{a_1}! ... @mvar{a_n}!)}.

Si no se dan argumentos, @code{multinomial_coeff()} devuelve 1.

Se puede usar @code{minfactorial} para simplificar el valor
devuelto por @code{multinomial_coeff}.

Ejemplos:

@c ===beg===
@c multinomial_coeff (1, 2, x);
@c minfactorial (%);
@c multinomial_coeff (-6, 2);
@c minfactorial (%);
@c ===end===
@example
(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
@end example
@end deffn


@deffn {Funci@'on} num_distinct_partitions (@mvar{n})
@deffnx {Funci@'on} num_distinct_partitions (@mvar{n}, @mvar{list})

Si @mvar{n} es un entero no negativo, devuelve el n@'umero de
particiones enteras distintas de @mvar{n}, en caso contrario
@code{num_distinct_partitions} devuelve una forma nominal.

La sentencia @code{num_distinct_partitions(@mvar{n}, list)}
devuelve una lista con el n@'umero de particiones distintas
de 1, 2, 3, ..., @mvar{n}.

Una partici@'on distinta de @mvar{n} es una lista de n@'umeros
enteros positivos distintos @math{k_1}, ..., @math{k_m}
tales que @math{@mvar{n} = k_1 + ... + k_m}.

Ejemplos:

@c ===beg===
@c num_distinct_partitions (12);
@c num_distinct_partitions (12, list);
@c num_distinct_partitions (n);
@c ===end===
@example
(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
@end example
@end deffn


@deffn {Funci@'on} num_partitions (@mvar{n})
@deffnx {Funci@'on} num_partitions (@mvar{n}, @mvar{list})

Si @mvar{n} es un entero no negativo, devuelve el n@'umero de
particiones enteras de @mvar{n}, en caso contrario @code{num_partitions}
devuelve una expresi@'on nominal.

La sentencia @code{num_partitions(@mvar{n}, list)} devuelve una lista
con los n@'umeros de particiones enteras de 1, 2, 3, ..., @mvar{n}.

Siendo @mvar{n} un entero no negativo, @code{num_partitions(@mvar{n})}
es igual a @code{cardinality(integer_partitions(@mvar{n}))}; sin
embargo, @code{num_partitions} no construye el conjunto de 
particiones, por lo que es m@'as r@'apido.

Ejemplos:

@c ===beg===
@c num_partitions (5) = cardinality (integer_partitions (5));
@c num_partitions (8, list);
@c num_partitions (n);
@c ===end===
@example
(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
@end example
@end deffn


@deffn {Funci@'on} partition_set (@mvar{a}, @mvar{f})

Particiona el conjunto @mvar{a} respecto del predicado @mvar{f}.

La funci@'on @code{partition_set} devuelve una lista con dos conjuntos;
el primer conjunto es el subconjunto de @mvar{a} para el cual el predicado
@mvar{f} devuelve @code{false} y el segundo contiene al resto de elementos de @mvar{a}.

La funci@'on @code{partition_set} no aplica @code{is} al valor devuelto
por @mvar{f}.

La funci@'on @code{partition_set} emite un mensaje de error si @mvar{a}
no es un conjunto literal.

V@'ease tambi@'en @code{subset}.

Ejemplos:

@c ===beg===
@c partition_set ({2, 7, 1, 8, 2, 8}, evenp);
@c partition_set ({x, rat(y), rat(y) + z, 1},
@c                 lambda ([x], ratp(x)));
@c ===end===
@example
(%i1) partition_set (@{2, 7, 1, 8, 2, 8@}, evenp);
(%o1)                   [@{1, 7@}, @{2, 8@}]
(%i2) partition_set (@{x, rat(y), rat(y) + z, 1@},
                  lambda ([x], ratp(x)));
(%o2)/R/              [@{1, x@}, @{y, y + z@}]
@end example
@end deffn


@deffn {Funci@'on} permutations (@mvar{a})

Devuelve un conjunto con todas las permutaciones distintas
de los miembros de la lista o conjunto  @mvar{a}. Cada permutaci@'on
es una lista, no un conjunto.

Si @mvar{a} es una lista, sus miembros duplicados no son eliminados
antes de buscar sus permutaciones.

Si @mvar{a} no es una lista o conjunto, @code{permutations} emite
un mensaje de error.

V@'ease tambi@'en @code{random_permutation}.

Ejemplos:

@c ===beg===
@c permutations ([a, a]);
@c permutations ([a, a, b]);
@c ===end===
@example
(%i1) permutations ([a, a]);
(%o1)                       @{[a, a]@}
(%i2) permutations ([a, a, b]);
(%o2)           @{[a, a, b], [a, b, a], [b, a, a]@}
@end example
@end deffn


@deffn {Funci@'on} powerset (@mvar{a})
@deffnx {Funci@'on} powerset (@mvar{a}, @mvar{n})

Devuelve el conjunto de todos los subconjuntos del conjunto @mvar{a}
o un sunconjunto de ellos.

La sentencia @code{powerset(@mvar{a})} devuelve el conjunto de todos
los subconjuntos de @mvar{a}, que contendr@'a @code{2^cardinality(@mvar{a})}
elementos.

La sentencia @code{powerset(@mvar{a}, @mvar{n})} devuelve el conjunto de todos
los subconjuntos de @mvar{a} de cardinalidad @mvar{n}.

La funci@'on @code{powerset} emite un mensaje de error si @mvar{a} no
es un conjunto literal o si @mvar{n} no es un entero no negativo.

Ejemplos:

@c ===beg===
@c powerset ({a, b, c});
@c powerset ({w, x, y, z}, 4);
@c powerset ({w, x, y, z}, 3);
@c powerset ({w, x, y, z}, 2);
@c powerset ({w, x, y, z}, 1);
@c powerset ({w, x, y, z}, 0);
@c ===end===
@example
(%i1) powerset (@{a, b, c@});
(%o1) @{@{@}, @{a@}, @{a, b@}, @{a, b, c@}, @{a, c@}, @{b@}, @{b, c@}, @{c@}@}
(%i2) powerset (@{w, x, y, z@}, 4);
(%o2)                    @{@{w, x, y, z@}@}
(%i3) powerset (@{w, x, y, z@}, 3);
(%o3)     @{@{w, x, y@}, @{w, x, z@}, @{w, y, z@}, @{x, y, z@}@}
(%i4) powerset (@{w, x, y, z@}, 2);
(%o4)   @{@{w, x@}, @{w, y@}, @{w, z@}, @{x, y@}, @{x, z@}, @{y, z@}@}
(%i5) powerset (@{w, x, y, z@}, 1);
(%o5)                 @{@{w@}, @{x@}, @{y@}, @{z@}@}
(%i6) powerset (@{w, x, y, z@}, 0);
(%o6)                         @{@{@}@}
@end example
@end deffn



@deffn {Funci@'on} random_permutation (@mvar{a})

Devuelve una permutaci@'on aleatoria del conjunto o lista
@mvar{a}, siguiendo el algoritmo de Knuth.

El valor devuelto es una lista nueva distinta del argumento,
incluso cuando todos los elementos son iguales. Sin embargo,
los elementos del argumento no se copian.

Ejemplos:

@c ===beg===
@c random_permutation ([a, b, c, 1, 2, 3]);
@c random_permutation ([a, b, c, 1, 2, 3]);
@c random_permutation ({x + 1, y + 2, z + 3});
@c random_permutation ({x + 1, y + 2, z + 3});
@c ===end===
@example
(%i1) random_permutation ([a, b, c, 1, 2, 3]);
(%o1)                  [c, 1, 2, 3, a, b]
(%i2) random_permutation ([a, b, c, 1, 2, 3]);
(%o2)                  [b, 3, 1, c, a, 2]
(%i3) random_permutation (@{x + 1, y + 2, z + 3@});
(%o3)                 [y + 2, z + 3, x + 1]
(%i4) random_permutation (@{x + 1, y + 2, z + 3@});
(%o4)                 [x + 1, y + 2, z + 3]
@end example

@end deffn




@deffn {Funci@'on} rreduce (@mvar{f}, @mvar{s})
@deffnx {Funci@'on} rreduce (@mvar{f}, @mvar{s}, @mvar{init})

Ampl@'{@dotless{i}}a la funci@'on binaria @mvar{F} a n-aria mediante
composici@'on, siendo @mvar{s} una lista.

La sentencia  @code{rreduce(@mvar{F}, @mvar{s})} devuelve
@code{F(s_1, ... F(s_@{n - 2@}, F(s_@{n - 1@}, s_n)))}.
Si se incluye el argumento opcional @mvar{s_@{n + 1@}},
el resultado equivale a @code{rreduce(@mvar{F}, endcons(@mvar{s_@{n + 1@}}, @mvar{s}))}.

La funci@'on @mvar{F} se aplica primero a los elementos del
extremo derecho de la lista, de ah@'{@dotless{i}} el nombre
@code{rreduce}, (@i{right reduce}).

V@'eanse tambi@'en @code{lreduce}, @code{xreduce} y @code{tree_reduce}.

Ejemplos:

La funci@'on @code{rreduce} sin el argumento opcional,

@c ===beg===
@c rreduce (f, [1, 2, 3]);
@c rreduce (f, [1, 2, 3, 4]);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
@end example

La funci@'on @code{rreduce} con el argumento opcional,

@c ===beg===
@c rreduce (f, [1, 2, 3], 4);
@c ===end===
@example
(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
@end example

La funci@'on @code{rreduce} aplicada a operadores binarios de Maxima.
El s@'{@dotless{i}}mbolo @code{/} es el operador divisi@'on.

@c ===beg===
@c rreduce ("^", args ({a, b, c, d}));
@c rreduce ("/", args ({a, b, c, d}));
@c ===end===
@example
(%i1) rreduce ("^", args (@{a, b, c, d@}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce ("/", args (@{a, b, c, d@}));
                               a c
(%o2)                          ---
                               b d
@end example
@end deffn


@deffn {Funci@'on}  setdifference (@mvar{a}, @mvar{b})

Devuelve el conjunto con los elementos del conjunto @mvar{a} que
no pertenecen al conjunto @mvar{b}.

La funci@'on @code{setdifference} emite un mensaje de error si
@mvar{a} o @mvar{b} no son conjuntos.

Ejemplos:

@c ===beg===
@c S_1 : {a, b, c, x, y, z};
@c S_2 : {aa, bb, c, x, y, zz};
@c setdifference (S_1, S_2);
@c setdifference (S_2, S_1);
@c setdifference (S_1, S_1);
@c setdifference (S_1, {});
@c setdifference ({}, S_1);
@c ===end===
@example
(%i1) S_1 : @{a, b, c, x, y, z@};
(%o1)                  @{a, b, c, x, y, z@}
(%i2) S_2 : @{aa, bb, c, x, y, zz@};
(%o2)                 @{aa, bb, c, x, y, zz@}
(%i3) setdifference (S_1, S_2);
(%o3)                       @{a, b, z@}
(%i4) setdifference (S_2, S_1);
(%o4)                     @{aa, bb, zz@}
(%i5) setdifference (S_1, S_1);
(%o5)                          @{@}
(%i6) setdifference (S_1, @{@});
(%o6)                  @{a, b, c, x, y, z@}
(%i7) setdifference (@{@}, S_1);
(%o7)                          @{@}
@end example
@end deffn


@deffn {Funci@'on} setequalp (@mvar{a}, @mvar{b})

Devuelve  @code{true} si los conjuntos @mvar{a} y @mvar{b} tienen
el mismo n@'umero de elementos
@c $SETEQUALP CALLS THE LISP FUNCTION LIKE,
@c AND SO DOES THE CODE TO EVALUATE IS (X = Y).
y @code{is (@mvar{x} = @mvar{y})} vale @code{true}
para @code{x} perteneciente a @mvar{a}
e @code{y} perteneciente a @mvar{b},
considerados en el orden que determina la funci@'on 
@code{listify}. En caso contrario, @code{setequalp}
devuelve @code{false}.

Ejemplos:

@c ===beg===
@c setequalp ({1, 2, 3}, {1, 2, 3});
@c setequalp ({a, b, c}, {1, 2, 3});
@c setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
@c ===end===
@example
(%i1) setequalp (@{1, 2, 3@}, @{1, 2, 3@});
(%o1)                         true
(%i2) setequalp (@{a, b, c@}, @{1, 2, 3@});
(%o2)                         false
(%i3) setequalp (@{x^2 - y^2@}, @{(x + y) * (x - y)@});
(%o3)                         false
@end example
@end deffn


@deffn {Funci@'on} setify (@mvar{a})

Construye un conjunto con los miembros de la lista @mvar{a}.
Los elementos duplicados de la lista @mvar{a} son borrados
y ordenados de acuerdo con el predicado @code{orderlessp}.

La funci@'on @code{setify} emite un mensaje de error si
@mvar{a} no es un conjunto literal.

Ejemplos:

@c ===beg===
@c setify ([1, 2, 3, a, b, c]);
@c setify ([a, b, c, a, b, c]);
@c setify ([7, 13, 11, 1, 3, 9, 5]);
@c ===end===
@example
(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  @{1, 2, 3, a, b, c@}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       @{a, b, c@}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                @{1, 3, 5, 7, 9, 11, 13@}
@end example
@end deffn


@deffn {Funci@'on} setp (@mvar{a})

Devuelve @code{true} si y s@'olo si @mvar{a} es un conjunto de Maxima.

La funci@'on @code{setp} devuelve @code{true} tanto cuando el conjunto
tiene como cuando no tiene elementos repetidos.

@c NOT SURE WE NEED TO MENTION THIS. OK FOR NOW
La funci@'on @code{setp} is equivalent to the Maxima function
@code{setp(a) := not atom(a) and op(a) = 'set}.

Ejemplos:

@c ===beg===
@c simp : false;
@c {a, a, a};
@c setp (%);
@c ===end===
@example
(%i1) simp : false;
(%o1)                         false
(%i2) @{a, a, a@};
(%o2)                       @{a, a, a@}
(%i3) setp (%);
(%o3)                         true
@end example
@end deffn


@deffn {Funci@'on} set_partitions (@mvar{a})
@deffnx {Funci@'on} set_partitions (@mvar{a}, @mvar{n})

Devuelve el conjunto de todas las particiones de @mvar{a} o
un subconjunto de ellas.

La sentencia @code{set_partitions(@mvar{a}, @mvar{n})}
devuelve un conjunto con todas las descomposiciones de @mvar{a}
en @mvar{n} conjuntos no vac@'{@dotless{i}}os disjuntos.

La sentencia @code{set_partitions(@mvar{a})} devuelve el
conjunto de todas las particiones.

La funci@'on @code{stirling2} devuelve la cardinalidad del conjunto
de las particiones de un conjunto.

Se dice que un conjunto @math{P} es una partici@'on del conjunto @math{S} si verifica

@enumerate
@item
cada elemento de @math{P} es un conjunto no vac@'{@dotless{i}}o, 
@item
los elementos de @math{P} son disjuntos,
@item
la uni@'on de los elementos de @math{P} es igual a  @math{S}.
@end enumerate

Ejemplos:

El conjunto vac@'{@dotless{i}}o forma una partici@'on de s@'{@dotless{i}} mismo,

@c ===beg===
@c set_partitions ({});
@c ===end===
@example
(%i1) set_partitions (@{@});
(%o1)                         @{@{@}@}
@end example

La cardinalidad del conjunto de particiones de un conjunto puede calcularse con @code{stirling2},

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c cardinality(p) = stirling2 (6, 3);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
@end example

Cada elemento de @code{p} deber@'{@dotless{i}}a tener @mvar{n} = 3 miembros,

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (cardinality, p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (cardinality, p);
(%o3)                          @{3@}
@end example

Por @'ultimo, para cada miembro de @code{p}, la uni@'on de sus elementos
debe ser igual a @code{s},

@c ===beg===
@c s: {0, 1, 2, 3, 4, 5}$
@c p: set_partitions (s, 3)$ 
@c map (lambda ([x], apply (union, listify (x))), p);
@c ===end===
@example
(%i1) s: @{0, 1, 2, 3, 4, 5@}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 @{@{0, 1, 2, 3, 4, 5@}@}
@end example
@end deffn


@deffn {Funci@'on} some (@mvar{f}, @mvar{a})
@deffnx {Funci@'on} some (@mvar{f}, @mvar{L_1}, ..., @mvar{L_n})

Devuelve @code{true} si el predicado @mvar{f} devuelve @code{true}
para al menos uno de sus argumentos.
Si el segundo argumento es un conjunto, @code{some (@mvar{f}, @mvar{a})}
devuelve @code{true} si @code{@mvar{f}(@mvar{a_i})} devuelve tambi@'en
@code{true} para alguno de los @mvar{a_i} en @mvar{a}; puede ser que
@code{some} no eval@'ue @mvar{f} para todos los @mvar{a_i} de @mvar{s}.
Puesto que los conjuntos no est@'an ordenados, @code{some} puede evaluar
@code{@mvar{f}(@mvar{a_i})} en cualquier orden.

Dada una o m@'as listas como argumentos,
@code{some (@mvar{f}, @mvar{L_1}, ..., @mvar{L_n})} devuelve @code{true}
si @code{@mvar{f}(@mvar{x_1}, ..., @mvar{x_n})} devuelve tambi@'en
@code{true} para al menos un  @mvar{x_1}, ..., @mvar{x_n} de
@mvar{L_1}, ..., @mvar{L_n}, respectivamente; puede ser que
@code{some} no eval@'ue @mvar{f} para todos las combinaciones
@mvar{x_1}, ..., @mvar{x_n}. La funci@'on @code{some} eval@'ua
las listas en el orden creciente de su @'{@dotless{i}}ndice

Dado un conjunto vac@'{@dotless{i}}o @code{@{@}} o una lista
vac@'{@dotless{i}}a como argumentos, @code{some} devuelve @code{false}.

Si la variable global @code{maperror} vale @code{true},
todas las listas @mvar{L_1}, ..., @mvar{L_n} deben tener
igual n@'umero de elementos. Si @code{maperror} vale
@code{false}, los argumentos se truncan para tener todos
el n@'umero de elementos de la lista m@'as corta. 

Los valores que devuelve el predicado @mvar{f} cuando toman 
(mediante @code{is}) un valor diferente a @code{true} y @code{false}
se controlan con la variable global @code{prederror}.
Si @code{prederror} vale @code{true}, tales valores se
consideran como @code{false}.
Si @code{prederror} vale @code{false}, tales valores se
consideran como desconocidos (@code{unknown}).

Ejemplos:

La funci@'on @code{some} aplicada a un @'unico conjunto.
El predicado es una funci@'on de un argumento,

@c ===beg===
@c some (integerp, {1, 2, 3, 4, 5, 6});
@c some (atom, {1, 2, sin(3), 4, 5 + y, 6});
@c ===end===
@example
(%i1) some (integerp, @{1, 2, 3, 4, 5, 6@});
(%o1)                         true
(%i2) some (atom, @{1, 2, sin(3), 4, 5 + y, 6@});
(%o2)                         true
@end example

La funci@'on @code{some} aplicada a dos listas.
El predicado es una funci@'on de dos argumentos,

@c ===beg===
@c some ("=", [a, b, c], [a, b, c]);
@c some ("#", [a, b, c], [a, b, c]);
@c ===end===
@example
(%i1) some ("=", [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some ("#", [a, b, c], [a, b, c]);
(%o2)                         false
@end example

Las respuestas del predicado @mvar{f} que se eval@'uan 
a cualquier cosa diferente de @code{true} y @code{false}
est@'an controlados por la variable global @code{prederror}.

@c ===beg===
@c prederror : false;
@c map (lambda ([a, b], is (a < b)), [x, y, z],
@c                 [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c prederror : true;
@c some ("<", [x, y, z], [x^2, y^2, z^2]);
@c some ("<", [x, y, z], [x^2, y^2, z + 1]);
@c ===end===
@example
(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a < b)), [x, y, z],
                     [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some ("<", [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some ("<", [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
@end example
@end deffn


@deffn {Funci@'on} stirling1 (@mvar{n}, @mvar{m})

Es el n@'umero de Stirling de primera especie.

Si tanto @mvar{n} como @mvar{m} son enteros no negativos,
el valor que toma @code{stirling1 (@mvar{n}, @mvar{m})}
es el n@'umero de permutaciones de un conjunto de
@mvar{n} elementos con @mvar{m} ciclos. Para m@'as detalles,
v@'ease Graham, Knuth and Patashnik @i{Concrete Mathematics}.
Maxima utiliza una relaci@'on recursiva para definir
@code{stirling1 (@mvar{n}, @mvar{m})} para @mvar{m} menor
que 0; no est@'a definida para @mvar{n} menor que 0 ni
para argumentos no enteros.

La funci@'on @code{stirling1} es simplificadora. Maxima
reconoce las siguientes identidades:

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling1(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling1(n, n) = 1} (Ref. [1])
@item
@math{stirling1(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling1(n + 1, 0) = 0} (Ref. [1])
@item
@math{stirling1(n + 1, 1) = n!} (Ref. [1])
@item
@math{stirling1(n + 1, 2) = 2^n  - 1} (Ref. [1])
@end enumerate

Estas identidades se aplican cuando los argumentos son enteros
literales o s@'{@dotless{i}}mbolos declarados como enteros y
el primer argumento es no negativo. La funci@'on @code{stirling1}
no simplifica para argumentos no enteros.

Referencias:

[1] Donald Knuth, @i{The Art of Computer Programming,}
Tercera Edici@'on, Volumen 1, Secci@'on 1.2.6, Ecuaciones 48, 49 y 50.

Ejemplos:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
@end example

La funci@'on @code{stirling1} no simplifica en caso de argumentos no enteros,

@c ===beg===
@c stirling1 (sqrt(2), sqrt(2));
@c ===end===
@example
(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
@end example

Maxima aplicas algunas identidades a @code{stirling1},

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling1 (n + 1, n);
@c stirling1 (n + 1, 1);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
@end example
@end deffn


@deffn {Funci@'on} stirling2 (@mvar{n}, @mvar{m})

Es el n@'umero de Stirling de segunda especie.

Si @mvar{n} y @mvar{m} son enteros no negativos,
@code{stirling2 (@mvar{n}, @mvar{m})} es el n@'umero
de formas en las que se puede particionar un conjunto
de cardinal @mvar{n} en @mvar{m} subconjuntos disjuntos.
Maxima utiliza una relaci@'on recursiva para definir
@code{stirling2 (@mvar{n}, @mvar{m})} con @mvar{m} menor
que 0; la funci@'on no est@'a definida para  @mvar{n}
menor que 0  ni para argumentos no enteros.

La funci@'on @code{stirling2} es simplificadora. Maxima
reconoce las siguientes identidades:

@c COPIED VERBATIM FROM SRC/NSET.LISP
@enumerate
@item
@math{stirling2(0, n) = kron_delta(0, n)} (Ref. [1])
@item
@math{stirling2(n, n) = 1} (Ref. [1])
@item
@math{stirling2(n, n - 1) = binomial(n, 2)} (Ref. [1])
@item
@math{stirling2(n + 1, 1) = 1} (Ref. [1])
@item
@math{stirling2(n + 1, 2) = 2^n  - 1} (Ref. [1])
@item
@math{stirling2(n, 0) = kron_delta(n, 0)} (Ref. [2])
@item
@math{stirling2(n, m) = 0} when @math{m > n} (Ref. [2])
@item
@math{stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) / m!}
si @math{m} y @math{n} son enteros y @math{n} no negativo. (Ref. [3])
@end enumerate

Estas identidades se aplican cuando los argumentos son enteros
literales o s@'{@dotless{i}}mbolos declarados como enteros y
el primer argumento es no negativo. La funci@'on @code{stirling2}
no simplifica para argumentos no enteros.

Referencias:

[1] Donald Knuth. @i{The Art of Computer Programming},
Tercera Edici@'on, Volumen 1, Secci@'on 1.2.6, Ecuaciones 48, 49 y 50.

[2] Graham, Knuth y Patashnik. @i{Concrete Mathematics}, Tabla 264.

[3] Abramowitz y Stegun. @i{Handbook of Mathematical Functions}, Secci@'on 24.1.4.

Ejemplos:

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n, n);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
@end example

La funci@'on @code{stirling2} no simplifica en caso de argumentos no enteros,

@c ===beg===
@c stirling2 (%pi, %pi);
@c ===end===
@example
(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
@end example

Maxima aplicas algunas identidades a @code{stirling2},

@c ===beg===
@c declare (n, integer)$
@c assume (n >= 0)$
@c stirling2 (n + 9, n + 8);
@c stirling2 (n + 1, 2);
@c ===end===
@example
(%i1) declare (n, integer)$
(%i2) assume (n >= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
@end example
@end deffn


@deffn {Funci@'on} subset (@mvar{a}, @mvar{f})

Devuelve el subconjunto del conjunto @mvar{a} que satisface el predicado @mvar{f}.

La funci@'on @code{subset} devuelve el conjunto que contiene a los
elementos de @mvar{a} para los cuales @mvar{f} devuelve un resultado
diferente de @code{false}. La funci@'on @code{subset} no aplica
@code{is} al valor retornado por @mvar{f}.

La funci@'on @code{subset} emite un mensaje de error si @mvar{a}
no es un conjunto literal.

V@'ease tambi@'en @code{partition_set}.

Ejemplos:

@c ===beg===
@c subset ({1, 2, x, x + y, z, x + y + z}, atom);
@c subset ({1, 2, 7, 8, 9, 14}, evenp);
@c ===end===
@example
(%i1) subset (@{1, 2, x, x + y, z, x + y + z@}, atom);
(%o1)                     @{1, 2, x, z@}
(%i2) subset (@{1, 2, 7, 8, 9, 14@}, evenp);
(%o2)                      @{2, 8, 14@}
@end example
@end deffn


@deffn {Funci@'on} subsetp (@mvar{a}, @mvar{b})

Devuelve @code{true} si y s@'olo si el conjunto @mvar{a} es un subconjunto de @mvar{b}.

La funci@'on @code{subsetp} emite un mensaje de error si
cualesquiera @mvar{a} o @mvar{b} no es un conjunto literal.

Ejemplos:

@c ===beg===
@c subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
@c subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
@c ===end===
@example
(%i1) subsetp (@{1, 2, 3@}, @{a, 1, b, 2, c, 3@});
(%o1)                         true
(%i2) subsetp (@{a, 1, b, 2, c, 3@}, @{1, 2, 3@});
(%o2)                         false
@end example
@end deffn



@deffn {Funci@'on} symmdifference (@mvar{a_1}, @dots{}, @mvar{a_n})

Devuelve la diferencia sim@'etrica de los conjuntos @code{ @mvar{a_1}, @dots{}, @mvar{a_n}}.

Dados dos argumentos, @code{symmdifference (@mvar{a}, @mvar{b})} equivale a
@code{union (setdifference (@mvar{a}, @mvar{b}), setdifference (@mvar{b}, @mvar{a}))}.

La funci@'on @code{symmdifference} emite un mensaje de error si alguno de
su argumentos no es un conjunto literal.

Ejemplos:

@c ===beg===
@c S_1 : {a, b, c};
@c S_2 : {1, b, c};
@c S_3 : {a, b, z};
@c symmdifference ();
@c symmdifference (S_1);
@c symmdifference (S_1, S_2);
@c symmdifference (S_1, S_2, S_3);
@c symmdifference ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c@};
(%o1)                       @{a, b, c@}
(%i2) S_2 : @{1, b, c@};
(%o2)                       @{1, b, c@}
(%i3) S_3 : @{a, b, z@};
(%o3)                       @{a, b, z@}
(%i4) symmdifference ();
(%o4)                          @{@}
(%i5) symmdifference (S_1);
(%o5)                       @{a, b, c@}
(%i6) symmdifference (S_1, S_2);
(%o6)                        @{1, a@}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                       @{1, b, z@}
(%i8) symmdifference (@{@}, S_1, S_2, S_3);
(%o8)                       @{1,b, z@}
@end example
@end deffn

@c TREE_REDUCE ACCEPTS A SET OR LIST AS AN ARGUMENT, BUT RREDUCE AND LREDUCE WANT ONLY LISTS; STRANGE
@deffn {Funci@'on} tree_reduce (@mvar{F}, @mvar{s})
@deffnx {Funci@'on} tree_reduce (@mvar{F}, @mvar{s}, @mvar{s_0})


Ampl@'{@dotless{i}}a la funci@'on binaria @mvar{F} a n-aria, siendo @mvar{s} una lista.

La funci@'on @code{tree_reduce} equivale a lo suguiente:
Aplicar @mvar{F} a pares sucesivos de elementos para formar
una nueva lista @code{[@mvar{F}(@mvar{s_1}, @mvar{s_2}), @mvar{F}(@mvar{s_3}, @mvar{s_4}), ...]},
llevando el elemento final sin cambiar si el n@'umero de elementos es impar;
despu@'es repetir hasta que la lista se reduzca a un @'unico elemento,
que es el valor de retorno.

Cuando est@'a presente el argumento opcional @mvar{s_0},
el resultado equivale a @code{tree_reduce(@mvar{F}, cons(@mvar{s_0}, @mvar{s})}.

Para la suma de n@'umeros decimales en coma flotante,
@code{tree_reduce} puede devolver una suma que tenga un error
de redondeo menor que el conseguido por @code{rreduce} o @code{lreduce}.

Los elementos de @mvar{s} y los resultados parciales pueden colocarse
en un @'arbol binario de m@'{@dotless{i}}nima profundidad, de ah@'{@dotless{i}}
el nombre de @i{tree_reduce}.

Ejemplos:

La funci@'on @code{tree_reduce} aplicada a una lista con un n@'umero
par de elementos,

@c ===beg===
@c tree_reduce (f, [a, b, c, d]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
@end example

La funci@'on @code{tree_reduce} aplicada a una lista con un n@'umero
impar de elementos,

@c ===beg===
@c tree_reduce (f, [a, b, c, d, e]);
@c ===end===
@example
(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
@end example
@end deffn


@deffn {Function} union (@mvar{a_1}, ..., @mvar{a_n})

Devuelve la uni@'on de los conjuntos @mvar{a_1} hasta @mvar{a_n}.

La sentencia @code{union()} (sin argumentos) devuelve el
conjunto vac@'{@dotless{i}}o.

La funci@'on @code{union} emite un mensaje de error si alguno
de sus argumentos no es un conjunto literal.

Ejemplos:

@c ===beg===
@c S_1 : {a, b, c + d, %e};
@c S_2 : {%pi, %i, %e, c + d};
@c S_3 : {17, 29, 1729, %pi, %i};
@c union ();
@c union (S_1);
@c union (S_1, S_2);
@c union (S_1, S_2, S_3);
@c union ({}, S_1, S_2, S_3);
@c ===end===
@example
(%i1) S_1 : @{a, b, c + d, %e@};
(%o1)                   @{%e, a, b, d + c@}
(%i2) S_2 : @{%pi, %i, %e, c + d@};
(%o2)                 @{%e, %i, %pi, d + c@}
(%i3) S_3 : @{17, 29, 1729, %pi, %i@};
(%o3)                @{17, 29, 1729, %i, %pi@}
(%i4) union ();
(%o4)                          @{@}
(%i5) union (S_1);
(%o5)                   @{%e, a, b, d + c@}
(%i6) union (S_1, S_2);
(%o6)              @{%e, %i, %pi, a, b, d + c@}
(%i7) union (S_1, S_2, S_3);
(%o7)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
(%i8) union (@{@}, S_1, S_2, S_3);
(%o8)       @{17, 29, 1729, %e, %i, %pi, a, b, d + c@}
@end example
@end deffn


@deffn {Funci@'on} xreduce (@mvar{F}, @mvar{s})
@deffnx {Funci@'on} xreduce (@mvar{F}, @mvar{s}, @mvar{s_0})



Ampl@'{@dotless{i}}a la funci@'on @mvar{F} a n-aria mediante
composici@'on; si @mvar{F} ya es n-aria, aplica @mvar{F} a @mvar{s}.
Si @mvar{F} no es n-aria, @code{xreduce} equivale a @code{lreduce}.
El argumento @mvar{s} debe ser una lista.

Funciones n-arias reconocidas por Maxima son la suma @code{+}, la
multiplicaci@'on @code{*}, @code{and}, @code{or}, @code{max},
@code{min} y @code{append}. Las funciones tambi@'en se pueden
declarar n-arias mediante @code{declare(@mvar{F}, nary)};
para estas funciones, @code{xreduce} ser@'a m@'as r@'apida que
@code{rreduce} o @code{lreduce}.

Cuando est@'a presente el argumento opcional @mvar{s_0},
el resultado equivale a @code{xreduce(@mvar{s}, cons(@mvar{s_0}, @mvar{s}))}.

La suma de n@'umeros decimales en coma flotante no es exactamente asociativa;
a@'un as@'{@dotless{i}}, @code{xreduce} aplica la suma n-aria cuando @mvar{s}
contiene n@'umeros en coma flotante.

Ejemplos:

La funci@'on @code{xreduce} aplicada a una funci@'on n-aria;
@code{F} es invocada una s@'ola vez, con todos sus argumentos,

@c ===beg===
@c declare (F, nary);
@c F ([L]) := L;
@c xreduce (F, [a, b, c, d, e]);
@c ===end===
@example
(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[("[", simp), a], b], c], d], e]
@end example

La funci@'on @code{xreduce} aplicada a una funci@'on que se desconoce si
es n-aria; @code{G} es invocada varias veces, con dos argumentos de cada vez,

@c ===beg===
@c G ([L]) := L;
@c xreduce (G, [a, b, c, d, e]);
@c lreduce (G, [a, b, c, d, e]);
@c ===end===
@example
(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[("[", simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
@end example
@end deffn







